import * as tsModule from 'typescript';
import { SimpleTypeKind, toSimpleType, toTypeString, isSimpleType as isSimpleType$1, isAssignableToSimpleTypeKind } from 'ts-simple-type';
import { relative } from 'path';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __awaiter(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

function __values(o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

/**
 * Takes a node and tries to resolve a constant value from it.
 * Returns undefined if no constant value can be resolved.
 * @param node
 * @param context
 */
function resolveNodeValue(node, context) {
    var e_1, _a, e_2, _b;
    var _c, _d;
    if (node == null)
        return undefined;
    var ts = context.ts, checker = context.checker;
    var depth = (context.depth || 0) + 1;
    // Always break when depth is larger than 10.
    // This ensures we cannot run into infinite recursion.
    if (depth > 10)
        return undefined;
    if (ts.isStringLiteralLike(node)) {
        return { value: node.text, node: node };
    }
    else if (ts.isNumericLiteral(node)) {
        return { value: Number(node.text), node: node };
    }
    else if (ts.isPrefixUnaryExpression(node)) {
        var value = (_c = resolveNodeValue(node.operand, __assign(__assign({}, context), { depth: depth }))) === null || _c === void 0 ? void 0 : _c.value;
        return { value: applyPrefixUnaryOperatorToValue(value, node.operator, ts), node: node };
    }
    else if (ts.isObjectLiteralExpression(node)) {
        var object = {};
        try {
            for (var _e = __values(node.properties), _f = _e.next(); !_f.done; _f = _e.next()) {
                var prop = _f.value;
                if (ts.isPropertyAssignment(prop)) {
                    // Resolve the "key"
                    var name_1 = ((_d = resolveNodeValue(prop.name, __assign(__assign({}, context), { depth: depth }))) === null || _d === void 0 ? void 0 : _d.value) || prop.name.getText();
                    // Resolve the "value
                    var resolvedValue = resolveNodeValue(prop.initializer, __assign(__assign({}, context), { depth: depth }));
                    if (resolvedValue != null && typeof name_1 === "string") {
                        object[name_1] = resolvedValue.value;
                    }
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_f && !_f.done && (_a = _e.return)) _a.call(_e);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return {
            value: object,
            node: node
        };
    }
    else if (node.kind === ts.SyntaxKind.TrueKeyword) {
        return { value: true, node: node };
    }
    else if (node.kind === ts.SyntaxKind.FalseKeyword) {
        return { value: false, node: node };
    }
    else if (node.kind === ts.SyntaxKind.NullKeyword) {
        return { value: null, node: node };
    }
    else if (node.kind === ts.SyntaxKind.UndefinedKeyword) {
        return { value: undefined, node: node };
    }
    // Resolve initializers for variable declarations
    if (ts.isVariableDeclaration(node)) {
        return resolveNodeValue(node.initializer, __assign(__assign({}, context), { depth: depth }));
    }
    // Resolve value of a property access expression. For example: MyEnum.RED
    else if (ts.isPropertyAccessExpression(node)) {
        return resolveNodeValue(node.name, __assign(__assign({}, context), { depth: depth }));
    }
    // Resolve [expression] parts of {[expression]: "value"}
    else if (ts.isComputedPropertyName(node)) {
        return resolveNodeValue(node.expression, __assign(__assign({}, context), { depth: depth }));
    }
    // Resolve initializer value of enum members.
    else if (ts.isEnumMember(node)) {
        if (node.initializer != null) {
            return resolveNodeValue(node.initializer, __assign(__assign({}, context), { depth: depth }));
        }
        else {
            return { value: node.parent.name.text + "." + node.name.getText(), node: node };
        }
    }
    // Resolve values of variables.
    else if (ts.isIdentifier(node) && checker != null) {
        var declarations = resolveDeclarations(node, { checker: checker, ts: ts });
        if (declarations.length > 0) {
            var resolved = resolveNodeValue(declarations[0], __assign(__assign({}, context), { depth: depth }));
            if (context.strict || resolved != null) {
                return resolved;
            }
        }
        return { value: node.getText(), node: node };
    }
    // Fallthrough
    //  - "my-value" as string
    //  - <any>"my-value"
    //  - ("my-value")
    else if (ts.isAsExpression(node) || ts.isTypeAssertion(node) || ts.isParenthesizedExpression(node)) {
        return resolveNodeValue(node.expression, __assign(__assign({}, context), { depth: depth }));
    }
    // static get is() {
    //    return "my-element";
    // }
    else if ((ts.isGetAccessor(node) || ts.isMethodDeclaration(node) || ts.isFunctionDeclaration(node)) && node.body != null) {
        try {
            for (var _g = __values(node.body.statements), _h = _g.next(); !_h.done; _h = _g.next()) {
                var stm = _h.value;
                if (ts.isReturnStatement(stm)) {
                    return resolveNodeValue(stm.expression, __assign(__assign({}, context), { depth: depth }));
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_h && !_h.done && (_b = _g.return)) _b.call(_g);
            }
            finally { if (e_2) throw e_2.error; }
        }
    }
    // [1, 2]
    else if (ts.isArrayLiteralExpression(node)) {
        return {
            node: node,
            value: node.elements.map(function (el) { var _a; return (_a = resolveNodeValue(el, __assign(__assign({}, context), { depth: depth }))) === null || _a === void 0 ? void 0 : _a.value; })
        };
    }
    return undefined;
}
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function applyPrefixUnaryOperatorToValue(value, operator, ts) {
    if (typeof value === "object" && value != null) {
        return value;
    }
    switch (operator) {
        case ts.SyntaxKind.MinusToken:
            return -value;
        case ts.SyntaxKind.ExclamationToken:
            return !value;
        case ts.SyntaxKind.PlusToken:
            return +value;
    }
    return value;
}

/**
 * Converts from snake case to camel case
 * @param str
 */
/**
 * Converts from camel case to snake case
 * @param str
 */
function camelToDashCase(str) {
    return str.replace(/[A-Z]/g, function (m) { return "-" + m.toLowerCase(); });
}
/**
 * Returns if a name is private (starts with "_" or "#");
 * @param name	 * @param name
 */
function isNamePrivate(name) {
    return name.startsWith("_") || name.startsWith("#");
}

/**
 * Resolves all relevant declarations of a specific node.
 * @param node
 * @param context
 */
function resolveDeclarations(node, context) {
    if (node == null)
        return [];
    var checker = context.checker, ts = context.ts;
    // Get the symbol
    var symbol = checker.getSymbolAtLocation(node);
    if (symbol == null)
        return [];
    // Resolve aliased symbols
    if (isAliasSymbol(symbol, ts)) {
        symbol = checker.getAliasedSymbol(symbol);
        if (symbol == null)
            return [];
    }
    // Filters all declarations
    var allDeclarations = symbol.getDeclarations() || [];
    var validDeclarations = allDeclarations.filter(function (declaration) { return !ts.isIdentifier(declaration); });
    if (validDeclarations.length > 0) {
        return validDeclarations;
    }
    else {
        var declaration = symbol.valueDeclaration;
        return declaration != null ? [declaration] : [];
    }
}
/**
 * Returns if the symbol has "alias" flag
 * @param symbol
 * @param ts
 */
function isAliasSymbol(symbol, ts) {
    return hasFlag(symbol.flags, ts.SymbolFlags.Alias);
}
/**
 * Returns a set of modifiers on a node
 * @param node
 * @param ts
 */
function getModifiersFromNode(node, ts) {
    var modifiers = new Set();
    if (hasModifier(node, ts.SyntaxKind.ReadonlyKeyword)) {
        modifiers.add("readonly");
    }
    if (hasModifier(node, ts.SyntaxKind.StaticKeyword)) {
        modifiers.add("static");
    }
    if (ts.isGetAccessor(node)) {
        modifiers.add("readonly");
    }
    return modifiers.size > 0 ? modifiers : undefined;
}
/**
 * Returns if a number has a flag
 * @param num
 * @param flag
 */
function hasFlag(num, flag) {
    return (num & flag) !== 0;
}
/**
 * Returns if a node has a specific modifier.
 * @param node
 * @param modifierKind
 */
function hasModifier(node, modifierKind) {
    if (node.modifiers == null)
        return false;
    return (node.modifiers || []).find(function (modifier) { return modifier.kind === modifierKind; }) != null;
}
/**
 * Returns the visibility of a node
 */
function getMemberVisibilityFromNode(node, ts) {
    if (hasModifier(node, ts.SyntaxKind.PrivateKeyword) || ("name" in node && ts.isIdentifier(node.name) && isNamePrivate(node.name.text))) {
        return "private";
    }
    else if (hasModifier(node, ts.SyntaxKind.ProtectedKeyword)) {
        return "protected";
    }
    else if (getNodeSourceFileLang(node) === "ts") {
        // Only return "public" in typescript land
        return "public";
    }
    return undefined;
}
/**
 * Returns all keys and corresponding interface/class declarations for keys in an interface.
 * @param interfaceDeclaration
 * @param context
 */
function getInterfaceKeys(interfaceDeclaration, context) {
    var e_1, _a;
    var extensions = [];
    var ts = context.ts, checker = context.checker;
    try {
        for (var _b = __values(interfaceDeclaration.members), _c = _b.next(); !_c.done; _c = _b.next()) {
            var member = _c.value;
            // { "my-button": MyButton; }
            if (ts.isPropertySignature(member) && member.type != null) {
                var resolvedKey = resolveNodeValue(member.name, context);
                if (resolvedKey == null) {
                    continue;
                }
                var declaration = void 0, identifier = void 0;
                if (ts.isTypeReferenceNode(member.type)) {
                    // { ____: MyButton; } or { ____: namespace.MyButton; }
                    identifier = member.type.typeName;
                    declaration = resolveDeclarations(identifier, { checker: checker, ts: ts })[0];
                }
                else if (ts.isTypeLiteralNode(member.type)) {
                    identifier = undefined;
                    declaration = member.type;
                }
                else {
                    continue;
                }
                if (declaration != null) {
                    extensions.push({ key: String(resolvedKey.value), keyNode: resolvedKey.node, declaration: declaration, identifier: identifier });
                }
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return extensions;
}
/**
 * Find a node recursively walking down the children of the tree. Depth first search.
 * @param node
 * @param test
 */
function findChild(node, test) {
    if (!node)
        return;
    if (test(node))
        return node;
    return node.forEachChild(function (child) { return findChild(child, test); });
}
/**
 * Find multiple children by walking down the children of the tree. Depth first search.
 * @param node
 * @param test
 * @param emit
 */
function findChildren(node, test, emit) {
    if (!node)
        return;
    if (test(node)) {
        emit(node);
    }
    node.forEachChild(function (child) { return findChildren(child, test, emit); });
}
/**
 * Returns the language of the node's source file
 * @param node
 */
function getNodeSourceFileLang(node) {
    return node.getSourceFile().fileName.endsWith("ts") ? "ts" : "js";
}
/**
 * Returns the leading comment for a given node
 * @param node
 * @param ts
 */
function getLeadingCommentForNode(node, ts) {
    var sourceFileText = node.getSourceFile().text;
    var leadingComments = ts.getLeadingCommentRanges(sourceFileText, node.pos);
    if (leadingComments != null && leadingComments.length > 0) {
        return sourceFileText.substring(leadingComments[0].pos, leadingComments[0].end);
    }
    return undefined;
}
/**
 * Returns if the node is in a module declaration context and has a specific name.
 * @param node
 * @param context
 * @param name
 */
function isExtensionInterface(node, context, name) {
    return context.ts.isInterfaceDeclaration(node) /*&& context.ts.isModuleBlock(node.parent)*/ && node.name.text === name;
}
/**
 * Returns the declaration name of a given node if possible.
 * @param node
 * @param context
 */
function getDeclarationName(node, context) {
    var _a;
    return (_a = getDeclarationIdentifier(node, context)) === null || _a === void 0 ? void 0 : _a.text;
}
/**
 * Returns the declaration name of a given node if possible.
 * @param node
 * @param context
 */
function getDeclarationIdentifier(node, context) {
    if (context.ts.isClassLike(node) || context.ts.isInterfaceDeclaration(node)) {
        return node.name;
    }
    else if (context.ts.isVariableDeclaration(node) && context.ts.isIdentifier(node.name)) {
        return node.name;
    }
    return undefined;
}

/**
 * Visits custom element definitions.
 * @param node
 * @param ts
 * @param checker
 */
function discoverDefinitions(node, _a) {
    var ts = _a.ts, checker = _a.checker;
    // customElements.define("my-element", MyElement)
    if (ts.isCallExpression(node)) {
        if (ts.isPropertyAccessExpression(node.expression) && node.expression.name.escapedText === "define") {
            var leftExpression = node.expression.expression;
            // Take "window.customElements" into account and return the "customElements" part
            if (ts.isPropertyAccessExpression(leftExpression) &&
                ts.isIdentifier(leftExpression.expression) &&
                leftExpression.expression.escapedText === "window") {
                leftExpression = leftExpression.name;
            }
            // Check if the "left expression" is called "customElements"
            if (ts.isIdentifier(leftExpression) &&
                leftExpression.escapedText === "customElements" &&
                node.expression.name != null &&
                ts.isIdentifier(node.expression.name)) {
                // Find the arguments of: define("my-element", MyElement)
                var _b = __read(node.arguments, 2), unresolvedTagNameNode = _b[0], identifierNode_1 = _b[1];
                // Resolve the tag name node
                // ("my-element", MyElement)
                var resolvedTagNameNode = resolveNodeValue(unresolvedTagNameNode, { ts: ts, checker: checker, strict: true });
                if (resolvedTagNameNode != null && identifierNode_1 != null && typeof resolvedTagNameNode.value === "string") {
                    var tagName_1 = resolvedTagNameNode.value;
                    var tagNameNode_1 = resolvedTagNameNode.node;
                    // (___, MyElement)
                    if (ts.isIdentifier(identifierNode_1)) {
                        var declarationNodes = resolveDeclarations(identifierNode_1, { checker: checker, ts: ts });
                        return declarationNodes.map(function (declarationNode) { return ({
                            tagName: tagName_1,
                            identifierNode: identifierNode_1,
                            tagNameNode: tagNameNode_1,
                            declarationNode: declarationNode
                        }); });
                    }
                    // (___, class { ... })
                    else if (ts.isClassLike(identifierNode_1) || ts.isInterfaceDeclaration(identifierNode_1)) {
                        return [
                            {
                                tagName: tagName_1,
                                tagNameNode: tagNameNode_1,
                                declarationNode: identifierNode_1
                            }
                        ];
                    }
                }
            }
        }
        return undefined;
    }
    // interface HTMLElementTagNameMap { "my-button": MyButton; }
    if (ts.isInterfaceDeclaration(node) && ["HTMLElementTagNameMap", "ElementTagNameMap"].includes(node.name.text)) {
        var extensions = getInterfaceKeys(node, { ts: ts, checker: checker });
        return extensions.map(function (_a) {
            var key = _a.key, keyNode = _a.keyNode, identifier = _a.identifier, declaration = _a.declaration;
            return ({
                tagName: key,
                tagNameNode: keyNode,
                identifierNode: identifier,
                declarationNode: declaration
            });
        });
    }
    return undefined;
}

/**
 * Flattens an array.
 * Use this function to keep support for node 10
 * @param array
 */
function arrayFlat(array) {
    return "flat" in array ? array.flat() : array.reduce(function (acc, a) { return __spread(acc, a); }, []);
}
/**
 * Filters an array returning only defined items
 * @param array
 */
function arrayDefined(array) {
    return array.filter(function (item) { return item != null; });
}

var NOTHING = Symbol();
/**
 * This function wraps a callback returning a value and cahced the value.
 * @param callback
 */
function lazy(callback) {
    var value = NOTHING;
    return function () {
        if (value === NOTHING) {
            value = callback();
        }
        return value;
    };
}

/**
 * Returns typescript jsdoc node for a given node
 * @param node
 * @param ts
 */
function getJSDocNode(node, ts) {
    var _a, _b, _c;
    var parent = (_b = (_a = ts.getJSDocTags(node)) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.parent;
    if (parent != null && ts.isJSDoc(parent)) {
        return parent;
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return (_c = node.jsDoc) === null || _c === void 0 ? void 0 : _c.find(function (n) { return ts.isJSDoc(n); });
}
function getJsDoc(node, tagNamesOrTs, ts) {
    // Overloaded case
    var tagNames = null;
    if (ts == null) {
        ts = tagNamesOrTs;
    }
    else {
        tagNames = tagNamesOrTs;
    }
    var jsDocNode = getJSDocNode(node, ts);
    // If we couldn't find jsdoc, find and parse the jsdoc string ourselves
    if (jsDocNode == null) {
        var leadingComment = getLeadingCommentForNode(node, ts);
        if (leadingComment != null) {
            return parseJsDocString(leadingComment);
        }
        return undefined;
    }
    // Parse all jsdoc tags
    // Typescript removes some information after parsing jsdoc tags, so unfortunately we will have to parse.
    return {
        description: jsDocNode.comment == null ? undefined : String(jsDocNode.comment),
        node: jsDocNode,
        tags: jsDocNode.tags == null
            ? []
            : arrayDefined(jsDocNode.tags.map(function (node) {
                var _a, _b, _c, _d;
                var tag = String(node.tagName.escapedText);
                if (tagNames != null && tagNames.length > 0 && !tagNames.includes(tag.toLowerCase())) {
                    return undefined;
                }
                // If Typescript generated a "type expression" or "name", comment will not include those.
                // We can't just use what typescript parsed because it doesn't include things like optional jsdoc: name notation [...]
                // Therefore we need to manually get the text and remove newlines/*
                var typeExpressionPart = "typeExpression" in node ? (_a = node.typeExpression) === null || _a === void 0 ? void 0 : _a.getText() : undefined;
                var namePart = "name" in node ? (_b = node.name) === null || _b === void 0 ? void 0 : _b.getText() : undefined;
                var fullComment = ((_c = typeExpressionPart) === null || _c === void 0 ? void 0 : _c.startsWith("@")) ? // To make matters worse, if Typescript can't parse a certain jsdoc, it will include the rest of the jsdocs tag from there in "typeExpressionPart"
                    // Therefore we check if there are multiple jsdoc tags in the string to only take the first one
                    // This will discard the following jsdocs, but at least we don't crash :-)
                    typeExpressionPart.split(/\n\s*\*\s?@/)[0] || ""
                    : "@" + tag + (typeExpressionPart != null ? " " + typeExpressionPart + " " : "") + (namePart != null ? " " + namePart + " " : "") + " " + (node.comment ||
                        "");
                return {
                    node: node,
                    tag: tag,
                    comment: (_d = node.comment) === null || _d === void 0 ? void 0 : _d.replace(/^\s*-\s*/, "").trim(),
                    parsed: lazy(function () { return parseJsDocTagString(fullComment); })
                };
            }))
    };
}
/**
 * Converts a given string to a SimpleType
 * Defaults to ANY
 * See http://usejsdoc.org/tags-type.html
 * @param str
 */
function parseSimpleJsDocTypeExpression(str) {
    // Fail safe if "str" is somehow undefined
    if (str == null) {
        return { kind: SimpleTypeKind.ANY };
    }
    // Parse normal types
    switch (str.toLowerCase()) {
        case "undefined":
            return { kind: SimpleTypeKind.UNDEFINED };
        case "null":
            return { kind: SimpleTypeKind.NULL };
        case "string":
            return { kind: SimpleTypeKind.STRING };
        case "number":
            return { kind: SimpleTypeKind.NUMBER };
        case "boolean":
            return { kind: SimpleTypeKind.BOOLEAN };
        case "array":
            return { kind: SimpleTypeKind.ARRAY, type: { kind: SimpleTypeKind.ANY } };
        case "object":
            return { kind: SimpleTypeKind.OBJECT, members: [] };
        case "any":
        case "*":
            return { kind: SimpleTypeKind.ANY };
    }
    // Match
    //  {  string  }
    if (str.startsWith(" ") || str.endsWith(" ")) {
        return parseSimpleJsDocTypeExpression(str.trim());
    }
    // Match:
    //   {string|number}
    if (str.includes("|")) {
        return {
            kind: SimpleTypeKind.UNION,
            types: str.split("|").map(function (str) {
                var childType = parseSimpleJsDocTypeExpression(str);
                // Convert ANY types to string literals so that {on|off} is "on"|"off" and not ANY|ANY
                if (childType.kind === SimpleTypeKind.ANY) {
                    return {
                        kind: SimpleTypeKind.STRING_LITERAL,
                        value: str
                    };
                }
                return childType;
            })
        };
    }
    // Match:
    //  {?number}       (nullable)
    //  {!number}       (not nullable)
    //  {...number}     (array of)
    var prefixMatch = str.match(/^(\?|!|(\.\.\.))(.+)$/);
    if (prefixMatch != null) {
        var modifier = prefixMatch[1];
        var type = parseSimpleJsDocTypeExpression(prefixMatch[3]);
        switch (modifier) {
            case "?":
                return {
                    kind: SimpleTypeKind.UNION,
                    types: [
                        {
                            kind: SimpleTypeKind.NULL
                        },
                        type
                    ]
                };
            case "!":
                return type;
            case "...":
                return {
                    kind: SimpleTypeKind.ARRAY,
                    type: type
                };
        }
    }
    // Match:
    //  {(......)}
    var parenMatch = str.match(/^\((.+)\)$/);
    if (parenMatch != null) {
        return parseSimpleJsDocTypeExpression(parenMatch[1]);
    }
    // Match
    //   {"red"}
    var stringLiteralMatch = str.match(/^["'](.+)["']$/);
    if (stringLiteralMatch != null) {
        return {
            kind: SimpleTypeKind.STRING_LITERAL,
            value: stringLiteralMatch[1]
        };
    }
    // Match
    //   {[number]}
    var arrayMatch = str.match(/^\[(.+)]$/);
    if (arrayMatch != null) {
        return {
            kind: SimpleTypeKind.ARRAY,
            type: parseSimpleJsDocTypeExpression(arrayMatch[1])
        };
    }
    return { kind: SimpleTypeKind.ANY };
}
/**
 * Finds a @type jsdoc tag in the jsdoc and returns the corresponding simple type
 * @param jsDoc
 */
function getJsDocType(jsDoc) {
    var _a;
    if (jsDoc.tags != null) {
        var typeJsDocTag = jsDoc.tags.find(function (t) { return t.tag === "type"; });
        if (typeJsDocTag != null) {
            // We get the text of the node because typescript strips the type jsdoc tag under certain circumstances
            var parsedJsDoc = parseJsDocTagString(((_a = typeJsDocTag.node) === null || _a === void 0 ? void 0 : _a.getText()) || "");
            if (parsedJsDoc.type != null) {
                return parseSimpleJsDocTypeExpression(parsedJsDoc.type);
            }
        }
    }
}
var JSDOC_TAGS_WITH_REQUIRED_NAME = ["param", "fires", "@element", "@customElement"];
/**
 * Parses "@tag {type} name description"
 * @param str
 */
function parseJsDocTagString(str) {
    var jsDocTag = {
        tag: ""
    };
    if (str[0] !== "@") {
        return jsDocTag;
    }
    var moveStr = function (byLength) {
        str = str.substring(typeof byLength === "number" ? byLength : byLength.length);
    };
    var unqouteStr = function (quotedStr) {
        return quotedStr.replace(/^['"](.+)["']$/, function (_, match) { return match; });
    };
    // Match tag
    // Example: "  @mytag"
    var tagResult = str.match(/^(\s*@(\S+))/);
    if (tagResult == null) {
        return jsDocTag;
    }
    else {
        // Move string to the end of the match
        // Example: "  @mytag|"
        moveStr(tagResult[1]);
        jsDocTag.tag = tagResult[2];
    }
    // Match type
    // Example: "   {MyType}"
    var typeResult = str.match(/^(\s*{([\s\S]*)})/);
    if (typeResult != null) {
        // Move string to the end of the match
        // Example: "  {MyType}|"
        moveStr(typeResult[1]);
        jsDocTag.type = typeResult[2];
    }
    // Match optional name
    // Example: "  [myname=mydefault]"
    var defaultNameResult = str.match(/^(\s*\[([\s\S]+)\])/);
    if (defaultNameResult != null) {
        // Move string to the end of the match
        // Example: "  [myname=mydefault]|"
        moveStr(defaultNameResult[1]);
        // Using [...] means that this doc is optional
        jsDocTag.optional = true;
        // Split the inner content between [...] into parts
        // Example:  "myname=mydefault" => "myname", "mydefault"
        var parts = defaultNameResult[2].split("=");
        if (parts.length === 2) {
            // Both name and default were given
            jsDocTag.name = unqouteStr(parts[0]);
            jsDocTag.default = parts[1];
        }
        else if (parts.length !== 0) {
            // No default was given
            jsDocTag.name = unqouteStr(parts[0]);
        }
    }
    else {
        // else, match required name
        // Example: "   myname"
        // A name is needed some jsdoc tags making it possible to include omit "-"
        // Therefore we don't look for "-" or line end if the name is required - in that case we only need to eat the first word to find the name.
        var regex = JSDOC_TAGS_WITH_REQUIRED_NAME.includes(jsDocTag.tag) ? /^(\s*(\S+))/ : /^(\s*(\S+))((\s*-[\s\S]+)|\s*)($|[\r\n])/;
        var nameResult = str.match(regex);
        if (nameResult != null) {
            // Move string to end of match
            // Example: "   myname|"
            moveStr(nameResult[1]);
            jsDocTag.name = unqouteStr(nameResult[2].trim());
        }
    }
    // Match comment
    if (str.length > 0) {
        // The rest of the string is parsed as comment. Remove "-" if needed.
        jsDocTag.description = str.replace(/^\s*-\s*/, "").trim() || undefined;
    }
    // Expand the name based on namespace and classname
    if (jsDocTag.name != null) {
        /**
         * The name could look like this, so we need to parse and the remove the class name and namespace from the name
         *   InputSwitch#[CustomEvent]input-switch-check-changed
         *   InputSwitch#input-switch-check-changed
         */
        var match = jsDocTag.name.match(/(.*)#(\[.*\])?(.*)/);
        if (match != null) {
            jsDocTag.className = match[1];
            jsDocTag.namespace = match[2];
            jsDocTag.name = match[3];
        }
    }
    return jsDocTag;
}
/**
 * Parses an entire jsdoc string
 * @param doc
 */
function parseJsDocString(doc) {
    var e_1, _a;
    // Prepare lines
    var lines = doc.split("\n").map(function (line) { return line.trim(); });
    var description = "";
    var readDescription = true;
    var currentTag = "";
    var tags = [];
    /**
     * Parsing will add to "currentTag" and commit it when necessary
     */
    var commitCurrentTag = function () {
        if (currentTag.length > 0) {
            var tagToCommit_1 = currentTag;
            var tagMatch = tagToCommit_1.match(/^@(\S+)\s*/);
            if (tagMatch != null) {
                tags.push({
                    parsed: lazy(function () { return parseJsDocTagString(tagToCommit_1); }),
                    node: undefined,
                    tag: tagMatch[1],
                    comment: tagToCommit_1.substr(tagMatch[0].length)
                });
            }
            currentTag = "";
        }
    };
    try {
        // Parse all lines one by one
        for (var lines_1 = __values(lines), lines_1_1 = lines_1.next(); !lines_1_1.done; lines_1_1 = lines_1.next()) {
            var line = lines_1_1.value;
            // Don't parse the last line ("*/")
            if (line.match(/\*\//)) {
                continue;
            }
            // Match a line like: "* @mytag description"
            var tagCommentMatch = line.match(/(^\s*\*\s*)@\s*/);
            if (tagCommentMatch != null) {
                // Commit current tag (if any has been read). Now "currentTag" will reset.
                commitCurrentTag();
                // Add everything on the line from "@"
                currentTag += line.substr(tagCommentMatch[1].length);
                // We hit a jsdoc tag, so don't read description anymore
                readDescription = false;
            }
            else if (!readDescription) {
                // If we are not reading the description, we are currently reading a multiline tag
                var commentMatch = line.match(/^\s*\*\s*/);
                if (commentMatch != null) {
                    currentTag += "\n" + line.substr(commentMatch[0].length);
                }
            }
            else {
                // Read everything after "*" into the description if we are currently reading the description
                // If we are on the first line, add everything after "/*"
                var startLineMatch = line.match(/^\s*\/\*\*/);
                if (startLineMatch != null) {
                    description += line.substr(startLineMatch[0].length);
                }
                // Add everything after "*" into the current description
                var commentMatch = line.match(/^\s*\*\s*/);
                if (commentMatch != null) {
                    if (description.length > 0) {
                        description += "\n";
                    }
                    description += line.substr(commentMatch[0].length);
                }
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (lines_1_1 && !lines_1_1.done && (_a = lines_1.return)) _a.call(lines_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    // Commit a tag if we were currently parsing one
    commitCurrentTag();
    if (description.length === 0 && tags.length === 0) {
        return undefined;
    }
    return {
        description: description,
        tags: tags
    };
}

/**
 * Discovers events dispatched
 * @param node
 * @param context
 */
function discoverEvents(node, context) {
    var ts = context.ts, checker = context.checker;
    // new CustomEvent("my-event");
    if (ts.isNewExpression(node)) {
        var expression = node.expression, args = node.arguments, typeArguments_1 = node.typeArguments;
        if (expression.getText() === "CustomEvent" && args && args.length >= 1) {
            var arg = args[0];
            if (ts.isStringLiteralLike(arg)) {
                var eventName = arg.text;
                // Either grab jsdoc from the new expression or from a possible call expression that its wrapped in
                var jsDoc = getJsDoc(expression, ts) ||
                    (ts.isCallLikeExpression(node.parent) && getJsDoc(node.parent.parent, ts)) ||
                    (ts.isExpressionStatement(node.parent) && getJsDoc(node.parent, ts)) ||
                    undefined;
                return [
                    {
                        jsDoc: jsDoc,
                        name: eventName,
                        node: node,
                        type: lazy(function () {
                            var _a;
                            return ((((_a = typeArguments_1) === null || _a === void 0 ? void 0 : _a[0]) != null && checker.getTypeFromTypeNode(typeArguments_1[0])) ||
                                {
                                    kind: SimpleTypeKind.ANY
                                });
                        })
                    }
                ];
            }
        }
    }
    return undefined;
}

/**
 * Discovers global feature defined on "HTMLElementEventMap" or "HTMLElement"
 */
var discoverGlobalFeatures = {
    event: function (node, context) {
        var e_1, _a;
        var _b, _c, _d, _e;
        var ts = context.ts;
        if (isExtensionInterface(node, context, "HTMLElementEventMap")) {
            var events = [];
            try {
                for (var _f = __values(node.members), _g = _f.next(); !_g.done; _g = _f.next()) {
                    var member = _g.value;
                    if (ts.isPropertySignature(member)) {
                        var name_1 = (_b = resolveNodeValue(member.name, context)) === null || _b === void 0 ? void 0 : _b.value;
                        if (name_1 != null && typeof name_1 === "string") {
                            events.push({
                                node: member.initializer || member,
                                jsDoc: getJsDoc(member, ts),
                                name: name_1,
                                type: lazy(function () { return ({ kind: SimpleTypeKind.ANY }); })
                            });
                        }
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_g && !_g.done && (_a = _f.return)) _a.call(_f);
                }
                finally { if (e_1) throw e_1.error; }
            }
            (_e = (_c = context) === null || _c === void 0 ? void 0 : (_d = _c).emitContinue) === null || _e === void 0 ? void 0 : _e.call(_d);
            return events;
        }
    },
    member: function (node, context) {
        var e_2, _a;
        var _b, _c, _d, _e;
        var ts = context.ts;
        if (isExtensionInterface(node, context, "HTMLElement")) {
            var members = [];
            var _loop_1 = function (member) {
                if (ts.isPropertySignature(member)) {
                    var name_2 = (_b = resolveNodeValue(member.name, context)) === null || _b === void 0 ? void 0 : _b.value;
                    if (name_2 != null && typeof name_2 === "string") {
                        members.push({
                            priority: "medium",
                            member: {
                                node: member,
                                jsDoc: getJsDoc(member, ts),
                                kind: "property",
                                propName: name_2,
                                type: lazy(function () { return context.checker.getTypeAtLocation(member); })
                            }
                        });
                    }
                }
            };
            try {
                for (var _f = __values(node.members), _g = _f.next(); !_g.done; _g = _f.next()) {
                    var member = _g.value;
                    _loop_1(member);
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_g && !_g.done && (_a = _f.return)) _a.call(_f);
                }
                finally { if (e_2) throw e_2.error; }
            }
            (_e = (_c = context) === null || _c === void 0 ? void 0 : (_d = _c).emitContinue) === null || _e === void 0 ? void 0 : _e.call(_d);
            return members;
        }
    }
};

/**
 * Discovers inheritance from a node by looking at "extends" and "implements"
 * @param node
 * @param context
 */
function discoverInheritance(node, context) {
    if (node == null)
        return;
    if (context.ts.isClassLike(node) || context.ts.isInterfaceDeclaration(node)) {
        // Visit inherited nodes
        var clauses_1 = [];
        resolveHeritageClauses(node, __assign(__assign({}, context), { emitHeritageClause: function (clause) { return clauses_1.push(clause); } }));
        return clauses_1;
    }
    return undefined;
}
/**
 * Visits and emit declaration members in each interface/class-like inherited node.
 * @param node
 * @param context
 */
function resolveHeritageClauses(node, context) {
    var e_1, _a, e_2, _b;
    if (node.heritageClauses != null) {
        try {
            for (var _c = __values(node.heritageClauses || []), _d = _c.next(); !_d.done; _d = _c.next()) {
                var heritage = _d.value;
                try {
                    for (var _e = (e_2 = void 0, __values(heritage.types)), _f = _e.next(); !_f.done; _f = _e.next()) {
                        var type = _f.value;
                        resolveHeritageClause(heritage, type.expression, context);
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }
}
/**
 * Resolves inheritance clauses from a node
 * @param heritage
 * @param node
 * @param context
 */
function resolveHeritageClause(heritage, node, context) {
    var e_3, _a, e_4, _b;
    var _c, _d, _e, _f, _g;
    var ts = context.ts;
    /**
     * Parse mixins
     */
    if (ts.isCallExpression(node)) {
        // Mixins
        var identifier = node.expression, args = node.arguments;
        // Extend classes given to the mixin
        // Example: class MyElement extends MyMixin(MyBase) --> MyBase
        // Example: class MyElement extends MyMixin(MyBase1, MyBase2) --> MyBase1, MyBase2
        var horizontalInheritance_1 = [];
        try {
            for (var args_1 = __values(args), args_1_1 = args_1.next(); !args_1_1.done; args_1_1 = args_1.next()) {
                var arg = args_1_1.value;
                resolveHeritageClause(heritage, arg, __assign(__assign({}, context), { emitHeritageClause: function (clause) { return horizontalInheritance_1.push(clause); } }));
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (args_1_1 && !args_1_1.done && (_a = args_1.return)) _a.call(args_1);
            }
            finally { if (e_3) throw e_3.error; }
        }
        // Resolve and traverse the mixin function
        // Example: class MyElement extends MyMixin(MyBase) --> MyMixin
        if (identifier != null && ts.isIdentifier(identifier)) {
            var resolved_1 = [];
            // Resolve the mixin class (find out what is being returned from the mixin)
            // And add the mixins as horizontal inheritance.
            resolveMixin(heritage, identifier, __assign(__assign({}, context), { emitHeritageNode: function (heritageNode) {
                    resolved_1.push(heritageNode);
                }, emitHeritageClause: function (clause) {
                    horizontalInheritance_1.push(clause);
                }, resolvedIdentifiers: new Set() }));
            (_d = (_c = context).emitHeritageClause) === null || _d === void 0 ? void 0 : _d.call(_c, {
                kind: "mixin",
                identifier: identifier,
                horizontalInherits: horizontalInheritance_1,
                resolved: resolved_1
            });
        }
    }
    else if (ts.isIdentifier(node)) {
        // Visit component declarations for each inherited node.
        var declarations = resolveDeclarationsDeep(node, context);
        var resolved = [];
        try {
            for (var declarations_1 = __values(declarations), declarations_1_1 = declarations_1.next(); !declarations_1_1.done; declarations_1_1 = declarations_1.next()) {
                var declaration = declarations_1_1.value;
                if (ts.isCallLikeExpression(declaration) || ts.isIdentifier(declaration)) {
                    resolveHeritageClause(heritage, declaration, context);
                }
                else {
                    resolved.push({
                        node: declaration,
                        identifier: ts.isClassLike(declaration) || ts.isInterfaceDeclaration(declaration) ? declaration.name : undefined
                    });
                }
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (declarations_1_1 && !declarations_1_1.done && (_b = declarations_1.return)) _b.call(declarations_1);
            }
            finally { if (e_4) throw e_4.error; }
        }
        var kind = heritage.token === ts.SyntaxKind.ImplementsKeyword || ts.isInterfaceDeclaration(heritage.parent)
            ? ((_e = node.text) === null || _e === void 0 ? void 0 : _e.toLowerCase().includes("mixin")) ? "mixin"
                : "interface"
            : "class";
        (_g = (_f = context).emitHeritageClause) === null || _g === void 0 ? void 0 : _g.call(_f, {
            kind: kind,
            identifier: node,
            resolved: resolved
        });
    }
    return undefined;
}
/**
 * Resolve a declaration by trying to find the real value
 * @param node
 * @param context
 */
function resolveDeclarationsDeep(node, context) {
    return resolveDeclarations(node, context).map(function (declaration) {
        if (context.ts.isVariableDeclaration(declaration) && declaration.initializer != null) {
            return declaration.initializer;
        }
        return declaration;
    });
}
/**
 * Resolves a mixin by finding the actual thing being extended
 * @param heritage
 * @param node
 * @param context
 */
function resolveMixin(heritage, node, context) {
    var e_5, _a;
    var _b, _c, _d, _e;
    var ts = context.ts;
    // First, resolve the node
    var declarations = resolveDeclarations(node, context);
    try {
        for (var declarations_2 = __values(declarations), declarations_2_1 = declarations_2.next(); !declarations_2_1.done; declarations_2_1 = declarations_2.next()) {
            var declaration = declarations_2_1.value;
            // Extend right away if the node is a class declaration
            if (context.ts.isClassLike(declaration) || context.ts.isInterfaceDeclaration(declaration)) {
                //extendWithDeclarationNode(declaration, context);
                (_c = (_b = context).emitHeritageNode) === null || _c === void 0 ? void 0 : _c.call(_b, { node: declaration, identifier: declaration.name });
                continue;
            }
            // Else find the first class declaration in the block
            // Note that we don't look for a return statement because this would complicate things
            var clzDecl = findChild(declaration, context.ts.isClassLike);
            if (clzDecl != null) {
                //extendWithDeclarationNode(clzDecl, context);
                (_e = (_d = context).emitHeritageNode) === null || _e === void 0 ? void 0 : _e.call(_d, { node: clzDecl, identifier: clzDecl.name });
                continue;
            }
            // If we didn't find any class declarations, we might be in a function that wraps a mixin
            // Therefore find the return statement and call this method recursively
            var returnNode = findChild(declaration, context.ts.isReturnStatement);
            if (returnNode != null && returnNode.expression != null && returnNode.expression !== node) {
                resolveHeritageClause(heritage, returnNode.expression, context);
                continue;
            }
            // Resolve any identifiers if the node is in a declaration file
            if (declaration.getSourceFile().isDeclarationFile) {
                findChildren(declaration, ts.isIdentifier, function (identifier) {
                    if (context.resolvedIdentifiers.has(identifier.text)) {
                        return;
                    }
                    context.resolvedIdentifiers.add(identifier.text);
                    //resolveMixin(heritage, identifier, context);
                    resolveMixin(heritage, identifier, __assign(__assign({}, context), { emitHeritageNode: function (n) {
                            resolveHeritageClause(heritage, n.identifier || n.node, context);
                        } }));
                });
            }
        }
    }
    catch (e_5_1) { e_5 = { error: e_5_1 }; }
    finally {
        try {
            if (declarations_2_1 && !declarations_2_1.done && (_a = declarations_2.return)) _a.call(declarations_2);
        }
        finally { if (e_5) throw e_5.error; }
    }
}

/**
 * Relax the type so that for example "string literal" become "string" and "function" become "any"
 * This is used for javascript files to provide type checking with Typescript type inferring
 * @param type
 */
function relaxType(type) {
    switch (type.kind) {
        case SimpleTypeKind.INTERSECTION:
        case SimpleTypeKind.UNION:
            return __assign(__assign({}, type), { types: type.types.map(function (t) { return relaxType(t); }) });
        case SimpleTypeKind.ENUM:
            return __assign(__assign({}, type), { types: type.types.map(function (t) { return relaxType(t); }) });
        case SimpleTypeKind.ARRAY:
            return __assign(__assign({}, type), { type: relaxType(type.type) });
        case SimpleTypeKind.PROMISE:
            return __assign(__assign({}, type), { type: relaxType(type.type) });
        case SimpleTypeKind.OBJECT:
            return {
                name: type.name,
                kind: SimpleTypeKind.OBJECT
            };
        case SimpleTypeKind.INTERFACE:
        case SimpleTypeKind.FUNCTION:
        case SimpleTypeKind.CLASS:
            return {
                name: type.name,
                kind: SimpleTypeKind.ANY
            };
        case SimpleTypeKind.NUMBER_LITERAL:
            return { kind: SimpleTypeKind.NUMBER };
        case SimpleTypeKind.STRING_LITERAL:
            return { kind: SimpleTypeKind.STRING };
        case SimpleTypeKind.BOOLEAN_LITERAL:
            return { kind: SimpleTypeKind.BOOLEAN };
        case SimpleTypeKind.BIG_INT_LITERAL:
            return { kind: SimpleTypeKind.BIG_INT };
        case SimpleTypeKind.ENUM_MEMBER:
            return __assign(__assign({}, type), { type: relaxType(type.type) });
        case SimpleTypeKind.ALIAS:
            return __assign(__assign({}, type), { target: relaxType(type.target) });
        case SimpleTypeKind.NULL:
        case SimpleTypeKind.UNDEFINED:
            return { kind: SimpleTypeKind.ANY };
        default:
            return type;
    }
}

/**
 * Discovers members based on standard vanilla custom element rules
 * @param node
 * @param context
 */
function discoverMembers(node, context) {
    var e_1, _a, e_2, _b;
    var _c, _d, _e, _f;
    var ts = context.ts, checker = context.checker;
    // Never pick up members not declared directly on the declaration node being traversed
    if (node.parent !== context.declarationNode) {
        return undefined;
    }
    // static get observedAttributes() { return ['c', 'l']; }
    if (ts.isGetAccessor(node) && hasModifier(node, ts.SyntaxKind.StaticKeyword)) {
        if (node.name.getText() === "observedAttributes" && node.body != null) {
            var members = [];
            // Find either the first "return" statement or the first "array literal expression"
            var arrayLiteralExpression = (_d = (_c = node.body.statements.find(function (statement) { return ts.isReturnStatement(statement); })) === null || _c === void 0 ? void 0 : _c.expression, (_d !== null && _d !== void 0 ? _d : node.body.statements.find(function (statement) { return ts.isArrayLiteralExpression(statement); })));
            if (arrayLiteralExpression != null && ts.isArrayLiteralExpression(arrayLiteralExpression)) {
                try {
                    // Emit an attribute for each string literal in the array.
                    for (var _g = __values(arrayLiteralExpression.elements), _h = _g.next(); !_h.done; _h = _g.next()) {
                        var attrNameNode = _h.value;
                        var attrName = ts.isStringLiteralLike(attrNameNode) ? attrNameNode.text : undefined;
                        if (attrName == null)
                            continue;
                        members.push({
                            priority: "medium",
                            member: {
                                node: attrNameNode,
                                jsDoc: getJsDoc(attrNameNode, ts),
                                kind: "attribute",
                                attrName: attrName,
                                type: undefined // () => ({ kind: SimpleTypeKind.ANY } as SimpleType),
                            }
                        });
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_h && !_h.done && (_a = _g.return)) _a.call(_g);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }
            return members;
        }
    }
    // class { myProp = "hello"; }
    else if (ts.isPropertyDeclaration(node) || ts.isPropertySignature(node)) {
        var name_1 = node.name, initializer = node.initializer;
        if (ts.isIdentifier(name_1) || ts.isStringLiteralLike(name_1)) {
            // Find default value based on initializer
            var resolvedDefaultValue = initializer != null ? resolveNodeValue(initializer, context) : undefined;
            var def = resolvedDefaultValue != null ? resolvedDefaultValue.value : (_e = initializer) === null || _e === void 0 ? void 0 : _e.getText();
            return [
                {
                    priority: "high",
                    member: {
                        node: node,
                        kind: "property",
                        jsDoc: getJsDoc(node, ts),
                        propName: name_1.text,
                        type: lazy(function () { return checker.getTypeAtLocation(node); }),
                        default: def,
                        visibility: getMemberVisibilityFromNode(node, ts),
                        modifiers: getModifiersFromNode(node, ts)
                        //required: isPropertyRequired(node, context.checker),
                    }
                }
            ];
        }
    }
    // class { set myProp(value: string) { ... } }
    else if (ts.isSetAccessor(node) || ts.isGetAccessor(node)) {
        var name_2 = node.name, parameters = node.parameters;
        if (ts.isIdentifier(name_2)) {
            var parameter_1 = ts.isSetAccessor(node) != null && ((_f = parameters) === null || _f === void 0 ? void 0 : _f.length) > 0 ? parameters[0] : undefined;
            return [
                {
                    priority: "high",
                    member: {
                        node: node,
                        jsDoc: getJsDoc(node, ts),
                        kind: "property",
                        propName: name_2.text,
                        type: lazy(function () { return (parameter_1 == null ? context.checker.getTypeAtLocation(node) : context.checker.getTypeAtLocation(parameter_1)); }),
                        visibility: getMemberVisibilityFromNode(node, ts),
                        modifiers: getModifiersFromNode(node, ts)
                    }
                }
            ];
        }
    }
    // constructor { super(); this.title = "Hello"; }
    else if (ts.isConstructorDeclaration(node)) {
        if (node.body != null) {
            var assignments = node.body.statements
                .filter(function (stmt) { return ts.isExpressionStatement(stmt); })
                .map(function (stmt) { return stmt.expression; })
                .filter(function (exp) { return ts.isBinaryExpression(exp); });
            var members = [];
            var _loop_1 = function (assignment) {
                var left = assignment.left, right = assignment.right;
                if (ts.isPropertyAccessExpression(left)) {
                    if (left.expression.kind === ts.SyntaxKind.ThisKeyword) {
                        var propName = left.name.getText();
                        var resolvedInitializer = resolveNodeValue(right, context);
                        var def = resolvedInitializer != null ? resolvedInitializer.value : undefined; //right.getText();
                        members.push({
                            priority: "low",
                            member: {
                                node: node,
                                kind: "property",
                                propName: propName,
                                default: def,
                                type: function () { return relaxType(toSimpleType(checker.getTypeAtLocation(right), checker)); },
                                jsDoc: getJsDoc(assignment.parent, ts),
                                visibility: isNamePrivate(propName) ? "private" : undefined
                            }
                        });
                    }
                }
            };
            try {
                for (var assignments_1 = __values(assignments), assignments_1_1 = assignments_1.next(); !assignments_1_1.done; assignments_1_1 = assignments_1.next()) {
                    var assignment = assignments_1_1.value;
                    _loop_1(assignment);
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (assignments_1_1 && !assignments_1_1.done && (_b = assignments_1.return)) _b.call(assignments_1);
                }
                finally { if (e_2) throw e_2.error; }
            }
            return members;
        }
    }
    return undefined;
}

/**
 * Discovers methods
 * @param node
 * @param context
 */
function discoverMethods(node, context) {
    var _a, _b;
    var ts = context.ts;
    // Never pick up method declaration not declared directly on the declaration node being traversed
    if (node.parent !== context.declarationNode) {
        return undefined;
    }
    // class { myMethod () {} }
    if ((ts.isMethodDeclaration(node) || ts.isMethodSignature(node)) && !hasModifier(node, ts.SyntaxKind.StaticKeyword)) {
        // Outscope static methods for now
        var name_1 = node.name.getText();
        if (isHTMLElementMethodName(name_1)) {
            return undefined;
        }
        // Allow the analyzer to analyze within methods
        (_b = (_a = context).emitContinue) === null || _b === void 0 ? void 0 : _b.call(_a);
        return [
            {
                jsDoc: getJsDoc(node, ts),
                name: name_1,
                node: node,
                visibility: getMemberVisibilityFromNode(node, ts),
                type: lazy(function () { return context.checker.getTypeAtLocation(node); })
            }
        ];
    }
    return undefined;
}
function isHTMLElementMethodName(name) {
    return ["attributeChangedCallback", "connectedCallback", "disconnectedCallback"].includes(name);
}

/**
 * Excludes nodes from "lib.dom.d.ts" if analyzeLibDom is false
 * @param node
 * @param context
 */
function excludeNode(node, context) {
    if (context.config.analyzeLibDom) {
        return undefined;
    }
    return isLibDom(node);
}
function isLibDom(node) {
    return node.getSourceFile().fileName.endsWith("lib.dom.d.ts");
}

var refineFeature = {
    member: function (memberResult, context) {
        var _a, _b;
        var member = memberResult.member;
        // Outscope "static" members for now
        if ((_b = (_a = member) === null || _a === void 0 ? void 0 : _a.modifiers) === null || _b === void 0 ? void 0 : _b.has("static")) {
            return undefined;
        }
        if (member.visibility == null) {
            var name_1 = member.kind === "attribute" ? member.attrName : member.propName;
            if (isNamePrivate(name_1)) {
                return __assign(__assign({}, memberResult), { member: __assign(__assign({}, member), { visibility: "private" }) });
            }
        }
        return memberResult;
    },
    method: function (method, context) {
        // Outscope "statics" for now
        if (method.visibility == null && isNamePrivate(method.name)) {
            return __assign(__assign({}, method), { visibility: "private" });
        }
        return method;
    }
};

/**
 * A flavor that discovers using standard custom element rules
 */
var CustomElementFlavor = /** @class */ (function () {
    function CustomElementFlavor() {
        this.excludeNode = excludeNode;
        this.discoverDefinitions = discoverDefinitions;
        this.discoverFeatures = {
            member: discoverMembers,
            event: discoverEvents,
            method: discoverMethods
        };
        this.discoverGlobalFeatures = discoverGlobalFeatures;
        this.refineFeature = refineFeature;
        this.discoverInheritance = discoverInheritance;
    }
    return CustomElementFlavor;
}());

/**
 * Transforms jsdoc tags to a T array using a "transform"
 * @param node
 * @param tagNames
 * @param transform
 * @param context
 */
function parseJsDocForNode(node, tagNames, transform, context) {
    var _a, _b;
    var tags = (getJsDoc(node, tagNames, context.ts) || {}).tags;
    if (tags != null && tags.length > 0) {
        (_b = (_a = context).emitContinue) === null || _b === void 0 ? void 0 : _b.call(_a);
        return arrayDefined(tags.map(function (tag) { return transform(tag.node, tag.parsed()); }));
    }
    return undefined;
}

/**
 * Discovers definitions using "@customElement" or "@element" jsdoc
 * @param node
 * @param context
 */
function discoverDefinitions$1(node, context) {
    // /** @customElement my-element */ myClass extends HTMLElement { ... }
    if (context.ts.isInterfaceDeclaration(node) || context.ts.isClassDeclaration(node)) {
        return parseJsDocForNode(node, ["customelement", "element"], function (tagNode, _a) {
            var name = _a.name;
            return {
                tagName: name || "",
                identifierNode: tagNode,
                declarationNode: node,
                definitionNode: tagNode
            };
        }, context);
    }
}

var discoverFeatures = {
    csspart: function (node, context) {
        if (context.ts.isInterfaceDeclaration(node) || context.ts.isClassDeclaration(node)) {
            return parseJsDocForNode(node, ["csspart"], function (tagNode, _a) {
                var name = _a.name, description = _a.description;
                if (name != null && name.length > 0) {
                    return {
                        name: name,
                        jsDoc: description != null ? { description: description } : undefined
                    };
                }
            }, context);
        }
    },
    cssproperty: function (node, context) {
        if (context.ts.isInterfaceDeclaration(node) || context.ts.isClassDeclaration(node)) {
            return parseJsDocForNode(node, ["cssprop", "cssproperty", "cssvar", "cssvariable"], function (tagNode, _a) {
                var name = _a.name, description = _a.description, type = _a.type, def = _a.default;
                if (name != null && name.length > 0) {
                    return {
                        name: name,
                        jsDoc: description != null ? { description: description } : undefined,
                        typeHint: type || undefined,
                        default: def
                    };
                }
            }, context);
        }
    },
    event: function (node, context) {
        if (context.ts.isInterfaceDeclaration(node) || context.ts.isClassDeclaration(node)) {
            return parseJsDocForNode(node, ["event", "fires", "emits"], function (tagNode, _a) {
                var name = _a.name, description = _a.description, type = _a.type;
                if (name != null && name.length > 0 && tagNode != null) {
                    return {
                        name: name,
                        jsDoc: description != null ? { description: description } : undefined,
                        type: lazy(function () { return (type && parseSimpleJsDocTypeExpression(type)) || { kind: SimpleTypeKind.ANY }; }),
                        typeHint: type,
                        node: tagNode
                    };
                }
            }, context);
        }
    },
    slot: function (node, context) {
        if (context.ts.isInterfaceDeclaration(node) || context.ts.isClassDeclaration(node)) {
            return parseJsDocForNode(node, ["slot"], function (tagNode, _a) {
                var name = _a.name, type = _a.type, description = _a.description;
                // Grab the type from jsdoc and use it to find permitted tag names
                // Example: @slot {"div"|"span"} myslot
                var permittedTagNameType = type == null ? undefined : parseSimpleJsDocTypeExpression(type);
                var permittedTagNames = (function () {
                    if (permittedTagNameType == null) {
                        return undefined;
                    }
                    switch (permittedTagNameType.kind) {
                        case SimpleTypeKind.STRING_LITERAL:
                            return [permittedTagNameType.value];
                        case SimpleTypeKind.UNION:
                            return permittedTagNameType.types
                                .filter(function (type) { return type.kind === SimpleTypeKind.STRING_LITERAL; })
                                .map(function (type) { return type.value; });
                        default:
                            return undefined;
                    }
                })();
                return {
                    name: name,
                    jsDoc: description != null ? { description: description } : undefined,
                    permittedTagNames: permittedTagNames
                };
            }, context);
        }
    },
    member: function (node, context) {
        if (context.ts.isInterfaceDeclaration(node) || context.ts.isClassDeclaration(node)) {
            var properties = parseJsDocForNode(node, ["prop", "property"], function (tagNode, _a) {
                var name = _a.name, def = _a.default, type = _a.type, description = _a.description;
                if (name != null && name.length > 0) {
                    return {
                        kind: "property",
                        propName: name,
                        jsDoc: description != null ? { description: description } : undefined,
                        typeHint: type,
                        type: lazy(function () { return (type && parseSimpleJsDocTypeExpression(type)) || { kind: SimpleTypeKind.ANY }; }),
                        node: tagNode,
                        default: def,
                        visibility: undefined,
                        reflect: undefined,
                        required: undefined,
                        deprecated: undefined
                    };
                }
            }, context);
            var attributes = parseJsDocForNode(node, ["attr", "attribute"], function (tagNode, _a) {
                var name = _a.name, def = _a.default, type = _a.type, description = _a.description;
                if (name != null && name.length > 0) {
                    return {
                        kind: "attribute",
                        attrName: name,
                        jsDoc: description != null ? { description: description } : undefined,
                        type: lazy(function () { return (type && parseSimpleJsDocTypeExpression(type)) || { kind: SimpleTypeKind.ANY }; }),
                        typeHint: type,
                        node: tagNode,
                        default: def,
                        visibility: undefined,
                        reflect: undefined,
                        required: undefined,
                        deprecated: undefined
                    };
                }
            }, context);
            if (attributes != null || properties != null) {
                return __spread((attributes || []), (properties || [])).map(function (member) { return ({
                    priority: getNodeSourceFileLang(node) === "js" ? "high" : "medium",
                    member: member
                }); });
            }
            return undefined;
        }
    }
};

var discoverGlobalFeatures$1 = {
    csspart: function (node, context) {
        var _a, _b;
        if (isExtensionInterface(node, context, "HTMLElement")) {
            return (_b = (_a = discoverFeatures).csspart) === null || _b === void 0 ? void 0 : _b.call(_a, node, context);
        }
    },
    cssproperty: function (node, context) {
        var _a, _b;
        if (isExtensionInterface(node, context, "HTMLElement")) {
            return (_b = (_a = discoverFeatures).cssproperty) === null || _b === void 0 ? void 0 : _b.call(_a, node, context);
        }
    },
    event: function (node, context) {
        var _a, _b;
        if (isExtensionInterface(node, context, "HTMLElement")) {
            return (_b = (_a = discoverFeatures).event) === null || _b === void 0 ? void 0 : _b.call(_a, node, context);
        }
    },
    slot: function (node, context) {
        var _a, _b;
        if (isExtensionInterface(node, context, "HTMLElement")) {
            return (_b = (_a = discoverFeatures).slot) === null || _b === void 0 ? void 0 : _b.call(_a, node, context);
        }
    },
    member: function (node, context) {
        var _a, _b, _c;
        if (isExtensionInterface(node, context, "HTMLElement")) {
            return (_c = (_a = discoverFeatures) === null || _a === void 0 ? void 0 : (_b = _a).member) === null || _c === void 0 ? void 0 : _c.call(_b, node, context);
        }
    }
};

/**
 * Refines a component declaration by using jsdoc tags
 * @param declaration
 * @param context
 */
function refineDeclaration(declaration, context) {
    if (declaration.jsDoc == null || declaration.jsDoc.tags == null) {
        return undefined;
    }
    // Applies the "@deprecated" jsdoc tag
    var deprecatedTag = declaration.jsDoc.tags.find(function (t) { return t.tag === "deprecated"; });
    if (deprecatedTag != null) {
        return __assign(__assign({}, declaration), { deprecated: deprecatedTag.comment || true });
    }
    return undefined;
}

/**
 * Refines features by looking at the jsdoc tags on the feature
 */
var refineFeature$1 = {
    event: function (event) {
        if (event.jsDoc == null || event.jsDoc.tags == null)
            return event;
        // Check if the feature has "@ignore" jsdoc tag
        if (hasIgnoreJsDocTag(event.jsDoc)) {
            return undefined;
        }
        return [applyJsDocDeprecated, applyJsDocVisibility, applyJsDocType].reduce(function (event, applyFunc) { return applyFunc(event, event.jsDoc); }, event);
    },
    method: function (method) {
        if (method.jsDoc == null || method.jsDoc.tags == null)
            return method;
        // Check if the feature has "@ignore" jsdoc tag
        if (hasIgnoreJsDocTag(method.jsDoc)) {
            return undefined;
        }
        method = [applyJsDocDeprecated, applyJsDocVisibility].reduce(function (method, applyFunc) { return applyFunc(method, method.jsDoc); }, method);
        return method;
    },
    member: function (memberResult) {
        var member = memberResult.member;
        // Return right away if the member doesn't have jsdoc
        if (member.jsDoc == null || member.jsDoc.tags == null)
            return memberResult;
        // Check if the feature has "@ignore" jsdoc tag
        if (hasIgnoreJsDocTag(member.jsDoc)) {
            return undefined;
        }
        var newMember = [
            applyJsDocDeprecated,
            applyJsDocVisibility,
            applyJsDocAttribute,
            applyJsDocRequired,
            applyJsDocDefault,
            applyJsDocReflect,
            applyJsDocType,
            applyJsDocModifiers
        ].reduce(function (member, applyFunc) { return applyFunc(member, member.jsDoc); }, member);
        // only member
        return {
            priority: memberResult.priority,
            member: newMember
        };
    }
};
/**
 * Applies the "@deprecated" jsdoc tag
 * @param feature
 * @param jsDoc
 */
function applyJsDocDeprecated(feature, jsDoc) {
    var _a;
    var deprecatedTag = (_a = jsDoc.tags) === null || _a === void 0 ? void 0 : _a.find(function (tag) { return tag.tag === "deprecated"; });
    if (deprecatedTag != null) {
        return __assign(__assign({}, feature), { deprecated: deprecatedTag.comment || true });
    }
    return feature;
}
/**
 * Applies the "@access" jsdoc tag
 * @param feature
 * @param jsDoc
 */
function applyJsDocVisibility(feature, jsDoc) {
    var _a;
    var visibilityTag = (_a = jsDoc.tags) === null || _a === void 0 ? void 0 : _a.find(function (tag) { return ["public", "protected", "private", "package", "access"].includes(tag.tag); }); // member + method
    if (visibilityTag != null) {
        return __assign(__assign({}, feature), { visibility: (function () {
                switch (visibilityTag.tag) {
                    case "public":
                        return "public";
                    case "protected":
                        return "protected";
                    case "package":
                    case "private":
                        return "private";
                    case "access":
                        switch (visibilityTag.parsed().name) {
                            case "public":
                                return "public";
                            case "protected":
                                return "protected";
                            case "private":
                            case "package":
                                return "private";
                            default:
                                return undefined;
                        }
                    default:
                        return undefined;
                }
            })() });
    }
    return feature;
}
/**
 * Applies the "@attribute" jsdoc tag
 * @param feature
 * @param jsDoc
 */
function applyJsDocAttribute(feature, jsDoc) {
    var _a;
    var attributeTag = (_a = jsDoc.tags) === null || _a === void 0 ? void 0 : _a.find(function (tag) { return ["attr", "attribute"].includes(tag.tag); });
    if (attributeTag != null && feature.attrName == null) {
        return __assign(__assign({}, feature), { attrName: attributeTag.parsed().name || feature.propName });
    }
    return feature;
}
/**
 * Applies the "@required" jsdoc tag
 * @param feature
 * @param jsDoc
 */
function applyJsDocRequired(feature, jsDoc) {
    var _a;
    var requiredTag = (_a = jsDoc.tags) === null || _a === void 0 ? void 0 : _a.find(function (tag) { return ["optional", "required"].includes(tag.tag); });
    if (requiredTag != null) {
        return __assign(__assign({}, feature), { required: requiredTag.tag === "required" });
    }
    return feature;
}
/**
 * Applies the "@readonly" jsdoc tag
 * @param feature
 * @param jsDoc
 */
function applyJsDocModifiers(feature, jsDoc) {
    var _a;
    var readonlyTag = (_a = jsDoc.tags) === null || _a === void 0 ? void 0 : _a.find(function (tag) { return tag.tag === "readonly"; });
    if (readonlyTag != null) {
        return __assign(__assign({}, feature), { modifiers: (feature.modifiers != null ? new Set(feature.modifiers) : new Set()).add("readonly") });
    }
    return feature;
}
/**
 * Applies the "@default" jsdoc tag
 * @param feature
 * @param jsDoc
 */
function applyJsDocDefault(feature, jsDoc) {
    var _a;
    var defaultTag = (_a = jsDoc.tags) === null || _a === void 0 ? void 0 : _a.find(function (tag) { return tag.tag === "default"; });
    if (defaultTag != null) {
        return __assign(__assign({}, feature), { default: defaultTag.comment });
    }
    return feature;
}
/**
 * Applies the "@reflect" jsdoc tag
 * @param feature
 * @param jsDoc
 */
function applyJsDocReflect(feature, jsDoc) {
    var _a;
    var reflectTag = (_a = jsDoc.tags) === null || _a === void 0 ? void 0 : _a.find(function (tag) { return tag.tag === "reflect"; });
    if (reflectTag != null && feature.reflect == null) {
        return __assign(__assign({}, feature), { reflect: (function () {
                switch (reflectTag.comment) {
                    case "to-attribute":
                        return "to-attribute";
                    case "to-property":
                        return "to-property";
                    case "both":
                        return "both";
                    default:
                        return undefined;
                }
            })() });
    }
    return feature;
}
/**
 * Applies the "@type" jsdoc tag
 * @param feature
 * @param jsDoc
 */
function applyJsDocType(feature, jsDoc) {
    var _a, _b;
    var typeTag = (_a = jsDoc.tags) === null || _a === void 0 ? void 0 : _a.find(function (tag) { return tag.tag === "type"; });
    if (typeTag != null && feature.typeHint == null) {
        var parsed_1 = typeTag.parsed();
        if (parsed_1.type != null && parsed_1.type.length > 0) {
            return __assign(__assign({}, feature), { typeHint: parsed_1.type, type: (_b = feature.type, (_b !== null && _b !== void 0 ? _b : lazy(function () { return parseSimpleJsDocTypeExpression(parsed_1.type || ""); }))) });
        }
    }
    return feature;
}
/**
 * Returns if jsdoc contains an ignore node
 * @param jsDoc
 */
function hasIgnoreJsDocTag(jsDoc) {
    var _a, _b;
    return ((_b = (_a = jsDoc) === null || _a === void 0 ? void 0 : _a.tags) === null || _b === void 0 ? void 0 : _b.find(function (tag) { return tag.tag === "ignore"; })) != null;
}

/**
 * Flavors for analyzing jsdoc related features
 */
var JsDocFlavor = /** @class */ (function () {
    function JsDocFlavor() {
        this.discoverDefinitions = discoverDefinitions$1;
        this.discoverFeatures = discoverFeatures;
        this.discoverGlobalFeatures = discoverGlobalFeatures$1;
        this.refineFeature = refineFeature$1;
        this.refineDeclaration = refineDeclaration;
    }
    return JsDocFlavor;
}());

/**
 * Discovers element definitions in "IntrinsicElements"
 * @param node
 * @param context
 */
function discoverDefinitions$2(node, context) {
    var ts = context.ts;
    if (ts.isInterfaceDeclaration(node)) {
        if (node.name.text === "IntrinsicElements") {
            var extensions = getInterfaceKeys(node, context);
            return extensions.map(function (_a) {
                var key = _a.key, keyNode = _a.keyNode, identifier = _a.identifier, declaration = _a.declaration;
                return ({
                    tagName: key,
                    tagNameNode: keyNode,
                    identifierNode: identifier,
                    declarationNode: declaration
                });
            });
        }
    }
    return undefined;
}

/**
 * Discovers members declared on "IntrinsicAttributes"
 */
var discoverGlobalFeatures$2 = {
    member: function (node, context) {
        var e_1, _a;
        var _b, _c, _d, _e;
        var ts = context.ts;
        if (ts.isInterfaceDeclaration(node) && node.name.text === "IntrinsicAttributes") {
            var members = [];
            var _loop_1 = function (member) {
                if (ts.isPropertySignature(member)) {
                    var name_1 = (_b = resolveNodeValue(member.name, context)) === null || _b === void 0 ? void 0 : _b.value;
                    if (name_1 != null && typeof name_1 === "string") {
                        members.push({
                            priority: "medium",
                            member: {
                                node: member,
                                jsDoc: getJsDoc(member, ts),
                                kind: "property",
                                propName: name_1,
                                attrName: name_1,
                                type: function () { return context.checker.getTypeAtLocation(member); }
                            }
                        });
                    }
                }
            };
            try {
                for (var _f = __values(node.members), _g = _f.next(); !_g.done; _g = _f.next()) {
                    var member = _g.value;
                    _loop_1(member);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_g && !_g.done && (_a = _f.return)) _a.call(_f);
                }
                finally { if (e_1) throw e_1.error; }
            }
            (_e = (_c = context) === null || _c === void 0 ? void 0 : (_d = _c).emitContinue) === null || _e === void 0 ? void 0 : _e.call(_d);
            return members;
        }
    }
};

/**
 * Flavors for analyzing jsx related features
 */
var JSXFlavor = /** @class */ (function () {
    function JSXFlavor() {
        this.discoverDefinitions = discoverDefinitions$2;
        this.discoverGlobalFeatures = discoverGlobalFeatures$2;
    }
    return JSXFlavor;
}());

/**
 * Visits lit-element related definitions.
 * Specifically it finds the usage of the @customElement decorator.
 * @param node
 * @param context
 */
function discoverDefinitions$3(node, context) {
    var e_1, _a;
    var ts = context.ts, checker = context.checker;
    // @customElement("my-element")
    if (ts.isClassDeclaration(node)) {
        try {
            // Visit all decorators on the class
            for (var _b = __values(node.decorators || []), _c = _b.next(); !_c.done; _c = _b.next()) {
                var decorator = _c.value;
                var callExpression = decorator.expression;
                // Find "@customElement"
                if (ts.isCallExpression(callExpression) && ts.isIdentifier(callExpression.expression)) {
                    var decoratorIdentifierName = callExpression.expression.escapedText;
                    // Decorators called "customElement"
                    if (decoratorIdentifierName === "customElement") {
                        // Resolve the value of the first argument. This is the tag name.
                        var unresolvedTagNameNode = callExpression.arguments[0];
                        var resolvedTagNameNode = resolveNodeValue(unresolvedTagNameNode, { ts: ts, checker: checker });
                        if (resolvedTagNameNode != null && typeof resolvedTagNameNode.value === "string") {
                            return [
                                {
                                    tagName: resolvedTagNameNode.value,
                                    tagNameNode: resolvedTagNameNode.node,
                                    declarationNode: node
                                }
                            ];
                        }
                    }
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return;
    }
    node.forEachChild(function (child) {
        discoverDefinitions$3(child, context);
    });
}

/**
 * Returns the text representation of an inheritance clause
 * @param inheritsClause
 */
function getNameFromInheritanceClause(inheritsClause) {
    switch (inheritsClause.kind) {
        case "class":
            return "{ " + inheritsClause.identifier.getText() + " }";
        case "interface":
            return "[ " + inheritsClause.identifier.getText() + " ]";
        case "mixin":
            return "( " + inheritsClause.identifier.getText() + " )";
    }
}
/**
 * Returns all inheritance tree clauses by flattening horizontal inherits recursively
 * @param inheritsClause
 */
function flattenInheritsClauseChain(inheritsClause) {
    var _a;
    var next = arrayFlat(((_a = inheritsClause.horizontalInherits) === null || _a === void 0 ? void 0 : _a.map(flattenInheritsClauseChain)) || []);
    return __spread([inheritsClause], next);
}
/**
 * Visits inheritance tree clause and emits texts
 * @param inheritsClauses
 * @param line
 * @param start
 * @param context
 */
function visitInheritanceTreeClauseEmitText(inheritsClauses, _a, context) {
    var e_1, _b;
    var line = _a.line, start = _a.start;
    var flattenedInheritsClauses = arrayFlat(inheritsClauses.map(function (inheritsClause) { return flattenInheritsClauseChain(inheritsClause); })).filter(function (clause) { var _a; return (_a = clause.resolved) === null || _a === void 0 ? void 0 : _a.some(function (n) { var _a; return ((_a = n.node) === null || _a === void 0 ? void 0 : _a.kind) !== 155; }); });
    var i = 0;
    try {
        for (var flattenedInheritsClauses_1 = __values(flattenedInheritsClauses), flattenedInheritsClauses_1_1 = flattenedInheritsClauses_1.next(); !flattenedInheritsClauses_1_1.done; flattenedInheritsClauses_1_1 = flattenedInheritsClauses_1.next()) {
            var flatInheritsClause = flattenedInheritsClauses_1_1.value;
            var nextStart = void 0;
            var name_1 = getNameFromInheritanceClause(flatInheritsClause);
            if (name_1 !== "{ HTMLElement }") {
                // Emit text for the resolved extends node recursively on next line
                if (flatInheritsClause.resolved != null) {
                    // This function returns the maximum width of the line
                    nextStart = visitInheritanceTreeNodeEmitText(flatInheritsClause.resolved, {
                        line: line + 1,
                        start: start
                    }, context);
                }
            }
            // Calculate padding
            var isLast = i >= flattenedInheritsClauses.length - 1;
            var preferredPadding = isLast ? context.rightPadding : context.minArrowSize;
            var size = Math.max(name_1.length + preferredPadding, (nextStart || 0) - start);
            var actualPadding = size - name_1.length;
            // Prepares the text
            var text = "" + name_1 + (isLast ? " ".repeat(actualPadding) : " <" + "-".repeat(actualPadding - 3) + " ");
            // Emit the text and grab next start
            start = context.emitText(text, { line: line, start: start });
            i += 1;
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (flattenedInheritsClauses_1_1 && !flattenedInheritsClauses_1_1.done && (_b = flattenedInheritsClauses_1.return)) _b.call(flattenedInheritsClauses_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return start;
}
/**
 * Visits an inheritance tree node recusively.
 * Emits text while traversing.
 * @param treeNode
 * @param line
 * @param start
 * @param context
 */
function visitInheritanceTreeNodeEmitText(treeNode, _a, context) {
    var line = _a.line, start = _a.start;
    var inherits = arrayFlat(treeNode.map(function (n) { return n.inherits || []; })).sort(function (a, b) { return (a.kind === b.kind ? 0 : a.kind === "interface" ? 1 : -1); });
    return visitInheritanceTreeClauseEmitText(inherits, { line: line, start: start }, context);
}
/**
 * Generates a textual representation of an inheritance tree.
 * @param treeNode
 */
function generateInheritanceTreeText(treeNode) {
    var _a;
    // Add the start node to the text
    var name = "{ " + (((_a = treeNode.identifier) === null || _a === void 0 ? void 0 : _a.getText()) || "") + " }";
    var startText = name + " <-- ";
    var lines = new Map();
    lines.set(0, startText);
    var pos = { line: 0, start: startText.length };
    // Visit the inheritance tree recursively
    visitInheritanceTreeNodeEmitText([treeNode], pos, {
        rightPadding: 3,
        minArrowSize: 5,
        emitText: function (text, _a) {
            var line = _a.line, start = _a.start;
            var existingText = lines.get(line) || "";
            var padding = " ".repeat(start - existingText.length);
            lines.set(line, existingText + padding + text);
            return start + text.length;
        }
    });
    // Join all lines
    return Array.from(lines.entries())
        .sort(function (_a, _b) {
        var _c = __read(_a, 1), lineA = _c[0];
        var _d = __read(_b, 1), lineB = _d[0];
        return (lineA < lineB ? -1 : 1);
    })
        .map(function (_a) {
        var _b = __read(_a, 2), text = _b[1];
        return text;
    })
        .join("\n");
}
/**
 * Visits inheritance tree clause
 * @param treeClause
 * @param context
 */
function visitInheritanceTreeClause(treeClause, context) {
    var _a, _b, _c, _d;
    (_b = (_a = context).emitTreeClause) === null || _b === void 0 ? void 0 : _b.call(_a, treeClause);
    (_c = treeClause.resolved) === null || _c === void 0 ? void 0 : _c.forEach(function (treeNode) { return visitInheritanceTreeNode(treeNode, context); });
    (_d = treeClause.horizontalInherits) === null || _d === void 0 ? void 0 : _d.forEach(function (clause) { return visitInheritanceTreeClause(clause, context); });
}
/**
 * Visits inheritance tree node
 * @param treeNode
 * @param context
 */
function visitInheritanceTreeNode(treeNode, context) {
    var _a, _b, _c;
    (_b = (_a = context).emitTreeNode) === null || _b === void 0 ? void 0 : _b.call(_a, treeNode);
    (_c = treeNode.inherits) === null || _c === void 0 ? void 0 : _c.forEach(function (clause) { return visitInheritanceTreeClause(clause, context); });
}
/**
 * Gets all unique resolved nodes in an inheritance tree
 * @param tree
 */
function getUniqueResolvedNodeForInheritanceTree(tree) {
    var nodes = new Set();
    visitInheritanceTreeNode(tree, {
        emitTreeNode: function (treeNode) { return nodes.add(treeNode.node); }
    });
    return nodes;
}
/**
 * Gets all mixins in an inheritance tree
 * @param tree
 */
function getMixinsForInheritanceTree(tree) {
    var mixins = new Set();
    visitInheritanceTreeNode(tree, {
        emitTreeClause: function (treeClause) {
            if (treeClause.kind === "mixin") {
                mixins.add(treeClause.identifier.text);
            }
        }
    });
    return mixins;
}
/**
 * Gets all extend nodes in an inheritance tree
 * @param tree
 */
function getExtendsForInheritanceTree(tree) {
    var ext = new Set();
    visitInheritanceTreeNode(tree, {
        emitTreeClause: function (treeClause) {
            if (treeClause.kind === "class" || treeClause.kind === "interface") {
                ext.add(treeClause.identifier.text);
            }
        }
    });
    return ext;
}

var LIT_ELEMENT_PROPERTY_DECORATOR_KINDS = ["property", "internalProperty"];
/**
 * Returns a potential lit element property decorator.
 * @param node
 * @param context
 */
function getLitElementPropertyDecorator(node, context) {
    var e_1, _a;
    if (node.decorators == null)
        return undefined;
    var ts = context.ts;
    try {
        // Find a decorator with "property" name.
        for (var _b = __values(node.decorators), _c = _b.next(); !_c.done; _c = _b.next()) {
            var decorator = _c.value;
            var expression = decorator.expression;
            // We find the first decorator calling specific identifier name (found in LIT_ELEMENT_PROPERTY_DECORATOR_KINDS)
            if (ts.isCallExpression(expression) && ts.isIdentifier(expression.expression)) {
                var identifier = expression.expression;
                var kind = identifier.text;
                if (LIT_ELEMENT_PROPERTY_DECORATOR_KINDS.includes(kind)) {
                    return { expression: expression, kind: kind };
                }
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
}
/**
 * Returns a potential lit property decorator configuration.
 * @param node
 * @param context
 */
function getLitElementPropertyDecoratorConfig(node, context) {
    var ts = context.ts;
    // Get reference to a possible "@property" decorator.
    var decorator = getLitElementPropertyDecorator(node, context);
    if (decorator != null) {
        // Parse the first argument to the decorator which is the lit-property configuration.
        var configNode = decorator.expression.arguments[0];
        // Add decorator to "nodes"
        var config = { node: { decorator: decorator.expression } };
        // Apply specific config based on the decorator kind
        switch (decorator.kind) {
            case "internalProperty":
                config.attribute = false;
                break;
        }
        // Get lit options from the object literal expression
        return configNode != null && ts.isObjectLiteralExpression(configNode) ? getLitPropertyOptions(configNode, context, config) : config;
    }
    return undefined;
}
/**
 * Parses an object literal expression and returns a lit property configuration.
 * @param node
 * @param existingConfig
 * @param context
 */
function getLitPropertyOptions(node, context, existingConfig) {
    if (existingConfig === void 0) { existingConfig = {}; }
    var ts = context.ts;
    // Build up the property configuration by looking at properties in the object literal expression
    return node.properties.reduce(function (config, property) {
        if (!ts.isPropertyAssignment(property))
            return config;
        var initializer = property.initializer;
        var kind = ts.isIdentifier(property.name) ? property.name.text : undefined;
        return parseLitPropertyOption({ kind: kind, initializer: initializer, config: config }, context);
    }, existingConfig);
}
function parseLitPropertyOption(_a, context) {
    var kind = _a.kind, initializer = _a.initializer, config = _a.config;
    var _b, _c;
    var ts = context.ts, checker = context.checker;
    // noinspection DuplicateCaseLabelJS
    switch (kind) {
        case "converter": {
            return __assign(__assign({}, config), { hasConverter: true });
        }
        case "reflect": {
            return __assign(__assign({}, config), { reflect: ((_b = resolveNodeValue(initializer, context)) === null || _b === void 0 ? void 0 : _b.value) === true });
        }
        case "attribute": {
            var attribute = void 0;
            if (initializer.kind === ts.SyntaxKind.TrueKeyword) {
                attribute = true;
            }
            else if (initializer.kind === ts.SyntaxKind.FalseKeyword) {
                attribute = false;
            }
            else if (ts.isStringLiteral(initializer)) {
                attribute = initializer.text;
            }
            return __assign(__assign({}, config), { attribute: attribute, node: __assign(__assign({}, (config.node || {})), { attribute: initializer }) });
        }
        case "type": {
            var type = void 0;
            var value = ts.isIdentifier(initializer) ? initializer.text : undefined;
            switch (value) {
                case "String":
                case "StringConstructor":
                    type = { kind: SimpleTypeKind.STRING };
                    break;
                case "Number":
                case "NumberConstructor":
                    type = { kind: SimpleTypeKind.NUMBER };
                    break;
                case "Boolean":
                case "BooleanConstructor":
                    type = { kind: SimpleTypeKind.BOOLEAN };
                    break;
                case "Array":
                case "ArrayConstructor":
                    type = { kind: SimpleTypeKind.ARRAY, type: { kind: SimpleTypeKind.ANY } };
                    break;
                case "Object":
                case "ObjectConstructor":
                    type = { kind: SimpleTypeKind.OBJECT, members: [] };
                    break;
                default:
                    // This is an unknown type, so set the name as a string
                    type = initializer.getText();
                    break;
            }
            return __assign(__assign({}, config), { type: type, node: __assign(__assign({}, (config.node || {})), { type: initializer }) });
        }
        // Polymer specific field
        case "value": {
            return __assign(__assign({}, config), { default: (_c = resolveNodeValue(initializer, { ts: ts, checker: checker })) === null || _c === void 0 ? void 0 : _c.value });
        }
    }
    return config;
}

/**
 * Parses lit-related declaration members.
 * This is primary by looking at the "@property" decorator and the "static get properties()".
 * @param node
 * @param context
 */
function discoverMembers$1(node, context) {
    var ts = context.ts;
    // Never pick up members not declared directly on the declaration node being traversed
    if (node.parent !== context.declarationNode) {
        return undefined;
    }
    // static get properties() { return { myProp: {type: String} } }
    if (ts.isGetAccessor(node) && hasModifier(node, ts.SyntaxKind.StaticKeyword)) {
        var name_1 = node.name.getText();
        if (name_1 === "properties" && node.body != null) {
            var returnStatement = node.body.statements.find(ts.isReturnStatement.bind(ts));
            if (returnStatement != null) {
                return parseStaticProperties(returnStatement, context);
            }
        }
    }
    // @property({type: String}) myProp = "hello";
    else if (ts.isSetAccessor(node) || ts.isGetAccessor(node) || ts.isPropertyDeclaration(node) || ts.isPropertySignature(node)) {
        return parsePropertyDecorator(node, context);
    }
}
/**
 * Visits a lit property decorator and returns members based on it.
 * @param node
 * @param context
 */
function parsePropertyDecorator(node, context) {
    var _a;
    var ts = context.ts, checker = context.checker;
    // Parse the content of a possible lit "@property" decorator.
    var litConfig = getLitElementPropertyDecoratorConfig(node, context);
    if (litConfig != null) {
        var propName = node.name.getText();
        // Get the attribute based on the configuration
        var attrName = getLitAttributeName(propName, litConfig, context);
        // Find the default value for this property
        var initializer = "initializer" in node ? node.initializer : undefined;
        var resolvedDefaultValue = initializer != null ? resolveNodeValue(initializer, context) : undefined;
        var def = resolvedDefaultValue != null ? resolvedDefaultValue.value : (_a = initializer) === null || _a === void 0 ? void 0 : _a.getText();
        // Find our if the property/attribute is required
        //const required = ("initializer" in node && isPropertyRequired(node, context.checker)) || undefined;
        var required = undefined;
        var jsDoc = getJsDoc(node, ts);
        // Emit a property with "attrName"
        return [
            {
                priority: "high",
                member: {
                    kind: "property",
                    propName: propName,
                    attrName: attrName,
                    type: lazy(function () {
                        var propType = checker.getTypeAtLocation(node);
                        var inJavascriptFile = getNodeSourceFileLang(node) === "js";
                        return inJavascriptFile && typeof litConfig.type === "object" && litConfig.type.kind === SimpleTypeKind.ANY ? litConfig.type : propType;
                    }),
                    node: node,
                    default: def,
                    required: required,
                    jsDoc: jsDoc,
                    meta: litConfig,
                    visibility: getMemberVisibilityFromNode(node, ts),
                    reflect: litConfig.reflect ? "both" : attrName != null ? "to-property" : undefined,
                    modifiers: getModifiersFromNode(node, ts)
                }
            }
        ];
    }
    return undefined;
}
/**
 * Returns if we are in a Polymer context.
 * @param context
 */
function inPolymerFlavorContext(context) {
    var _a, _b;
    var declaration = context.getDeclaration();
    var cacheKey = "isPolymerFlavorContext:" + context.getDefinition().tagName;
    if (context.cache.general.has(cacheKey)) {
        return context.cache.general.get(cacheKey);
    }
    var result = false;
    // Use "@polymer" jsdoc tag to indicate that this is polymer context
    if ((_b = (_a = declaration.jsDoc) === null || _a === void 0 ? void 0 : _a.tags) === null || _b === void 0 ? void 0 : _b.some(function (t) { return t.tag === "polymer" || t.tag === "polymerElement"; })) {
        result = true;
    }
    var extnds = getExtendsForInheritanceTree(declaration.inheritanceTree);
    if (extnds.has("PolymerElement") || extnds.has("Polymer.Element")) {
        result = true;
    }
    context.cache.general.set(cacheKey, result);
    return result;
}
/**
 * Returns an attribute name based on a property name and a lit-configuration
 * @param propName
 * @param litConfig
 * @param context
 */
function getLitAttributeName(propName, litConfig, context) {
    // Don't emit attribute if the value is specifically "false"
    if (litConfig.attribute === false) {
        return undefined;
    }
    // Get the attribute name either by looking at "{attribute: ...}" or just taking the property name.
    var attrName = typeof litConfig.attribute === "string" ? litConfig.attribute : propName;
    if (inPolymerFlavorContext(context)) {
        // From the documentation: https://polymer-library.polymer-project.org/3.0/docs/devguide/properties#attribute-reflection
        attrName = camelToDashCase(attrName).toLowerCase();
    }
    return attrName;
}
/**
 * Visits static properties
 * static get properties() { return { myProp: {type: String, attribute: "my-attr"} } }
 * @param returnStatement
 * @param context
 */
function parseStaticProperties(returnStatement, context) {
    var e_1, _a;
    var ts = context.ts;
    var memberResults = [];
    if (returnStatement.expression != null && ts.isObjectLiteralExpression(returnStatement.expression)) {
        var isPolymerFlavor = inPolymerFlavorContext(context);
        var _loop_1 = function (propNode) {
            // Get propName
            var propName = propNode.name != null && ts.isIdentifier(propNode.name) ? propNode.name.text : undefined;
            if (propName == null) {
                return "continue";
            }
            // Parse the lit property config for this property
            // Treat non-object-literal-expressions like the "type" (to support Polymer specific syntax)
            var litConfig = ts.isPropertyAssignment(propNode)
                ? ts.isObjectLiteralExpression(propNode.initializer)
                    ? getLitPropertyOptions(propNode.initializer, context)
                    : isPolymerFlavor
                        ? parseLitPropertyOption({
                            kind: "type",
                            initializer: propNode.initializer,
                            config: {}
                        }, context)
                        : {}
                : {};
            // Get attrName based on the litConfig
            var attrName = getLitAttributeName(propName, litConfig, context);
            // Get more metadata
            var jsDoc = getJsDoc(propNode, ts);
            var emitAttribute = litConfig.attribute !== false;
            // Emit either the attribute or the property
            memberResults.push({
                priority: "high",
                member: {
                    kind: "property",
                    type: lazy(function () {
                        return (jsDoc && getJsDocType(jsDoc)) || (typeof litConfig.type === "object" && litConfig.type) || { kind: SimpleTypeKind.ANY };
                    }),
                    propName: propName,
                    attrName: emitAttribute ? attrName : undefined,
                    jsDoc: jsDoc,
                    node: propNode,
                    meta: litConfig,
                    default: litConfig.default,
                    reflect: litConfig.reflect ? "both" : attrName != null ? "to-property" : undefined
                }
            });
        };
        try {
            // Each property in the object literal expression corresponds to a class field.
            for (var _b = __values(returnStatement.expression.properties), _c = _b.next(); !_c.done; _c = _b.next()) {
                var propNode = _c.value;
                _loop_1(propNode);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }
    return memberResults;
}

function excludeNode$1(node, context) {
    if (context.config.analyzeLib) {
        return undefined;
    }
    // Exclude lit element related super classes if "analyzeLib" is false
    var declName = getDeclarationName(node, context);
    if (declName != null) {
        return declName === "LitElement" || declName === "UpdatingElement";
    }
    else {
        var fileName = node.getSourceFile().fileName;
        return fileName.includes("/lit-element.") || fileName.endsWith("/updating-element.");
    }
}

var refineFeature$2 = {
    method: function (method, context) {
        // This is temporary, but for now we force lit-element named methods to be protected
        if (LIT_ELEMENT_PROTECTED_METHODS.includes(method.name)) {
            return __assign(__assign({}, method), { visibility: "protected" });
        }
        return method;
    }
};
var LIT_ELEMENT_PROTECTED_METHODS = ["render", "requestUpdate", "firstUpdated", "updated", "update", "shouldUpdate"];

/**
 * Flavors for analyzing LitElement related features: https://lit-element.polymer-project.org/
 */
var LitElementFlavor = /** @class */ (function () {
    function LitElementFlavor() {
        this.excludeNode = excludeNode$1;
        this.discoverDefinitions = discoverDefinitions$3;
        this.discoverFeatures = {
            member: discoverMembers$1
        };
        this.refineFeature = refineFeature$2;
    }
    return LitElementFlavor;
}());

var VERSION = "1.0.3";
var DEFAULT_FLAVORS = [new LitElementFlavor(), new CustomElementFlavor(), new JsDocFlavor(), new JSXFlavor()];
var DEFAULT_FEATURE_COLLECTION_CACHE = new WeakMap();

var ALL_COMPONENT_FEATURES = ["member", "method", "cssproperty", "csspart", "event", "slot"];

/**
 * Creates an "analyzer visit context" based on some options
 * @param options
 */
function makeContextFromConfig(options) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    if (options.program == null) {
        throw new Error("A program is required when running 'analyzeSourceFile'");
    }
    // Assign defaults
    var flavors = options.flavors || DEFAULT_FLAVORS;
    var ts = options.ts || tsModule;
    var checker = options.program.getTypeChecker();
    // Create context
    return {
        checker: checker,
        ts: ts,
        flavors: flavors,
        cache: {
            featureCollection: DEFAULT_FEATURE_COLLECTION_CACHE,
            general: new Map()
        },
        config: __assign(__assign({}, options.config), { analyzeLibDom: (_b = (_a = options.config) === null || _a === void 0 ? void 0 : _a.analyzeLibDom, (_b !== null && _b !== void 0 ? _b : false)), analyzeLib: (_d = (_c = options.config) === null || _c === void 0 ? void 0 : _c.analyzeLib, (_d !== null && _d !== void 0 ? _d : false)), excludedDeclarationNames: (_f = (_e = options.config) === null || _e === void 0 ? void 0 : _e.excludedDeclarationNames, (_f !== null && _f !== void 0 ? _f : [])), features: (_h = (_g = options.config) === null || _g === void 0 ? void 0 : _g.features, (_h !== null && _h !== void 0 ? _h : ALL_COMPONENT_FEATURES)) })
    };
}

/**
 * Prepares a map of component features and a callback map that adds to the component feature map.
 */
function prepareRefineEmitMap() {
    var collection = {
        memberResults: [],
        methods: [],
        events: [],
        slots: [],
        cssProperties: [],
        cssParts: []
    };
    var refineEmitMap = {
        event: function (event) { return collection.events.push(event); },
        member: function (memberResult) { return collection.memberResults.push(memberResult); },
        csspart: function (cssPart) { return collection.cssParts.push(cssPart); },
        cssproperty: function (cssProperty) { return collection.cssProperties.push(cssProperty); },
        method: function (method) { return collection.methods.push(method); },
        slot: function (slot) { return collection.slots.push(slot); }
    };
    return {
        collection: collection,
        refineEmitMap: refineEmitMap
    };
}

/**
 * Uses flavors to refine a feature
 * Flavors can also remove a feature
 * @param featureKind
 * @param value
 * @param context
 * @param emitMap
 */
function refineFeature$3(featureKind, value, context, emitMap) {
    /*if (Array.isArray(value)) {
        value.forEach(v => refineComponentFeature(featureKind, v, context, emitMap));
        return;
    }*/
    var e_1, _a, e_2, _b;
    var _c;
    var refinedValue = value;
    try {
        for (var _d = __values(context.flavors), _e = _d.next(); !_e.done; _e = _d.next()) {
            var flavor = _e.value;
            var refineFunc = (_c = flavor.refineFeature) === null || _c === void 0 ? void 0 : _c[featureKind];
            if (refineFunc != null) {
                if (refinedValue == null) {
                    return;
                }
                else if (Array.isArray(refinedValue)) {
                    var newValue = [];
                    try {
                        for (var refinedValue_1 = (e_2 = void 0, __values(refinedValue)), refinedValue_1_1 = refinedValue_1.next(); !refinedValue_1_1.done; refinedValue_1_1 = refinedValue_1.next()) {
                            var val = refinedValue_1_1.value;
                            // eslint-disable-next-line @typescript-eslint/no-explicit-any
                            var refined = refineFunc(val, context);
                            if (refined != null) {
                                newValue.push.apply(newValue, __spread((Array.isArray(refined) ? refined : [refined])));
                            }
                        }
                    }
                    catch (e_2_1) { e_2 = { error: e_2_1 }; }
                    finally {
                        try {
                            if (refinedValue_1_1 && !refinedValue_1_1.done && (_b = refinedValue_1.return)) _b.call(refinedValue_1);
                        }
                        finally { if (e_2) throw e_2.error; }
                    }
                    refinedValue = newValue.length === 0 ? undefined : newValue;
                }
                else {
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    refinedValue = refineFunc(refinedValue, context);
                }
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
        }
        finally { if (e_1) throw e_1.error; }
    }
    if (refinedValue != null) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        (Array.isArray(refinedValue) ? refinedValue : [refinedValue]).forEach(function (v) { var _a, _b, _c; return (_c = (_a = emitMap) === null || _a === void 0 ? void 0 : (_b = _a)[featureKind]) === null || _c === void 0 ? void 0 : _c.call(_b, v); });
    }
}

/**
 * Uses flavors to find features for a node
 * @param node
 * @param context
 * @param emitMap
 */
function visitFeatures(node, context, emitMap) {
    var visitMaps = arrayDefined(context.flavors.map(function (flavor) { return flavor.discoverFeatures; }));
    visitFeaturesWithVisitMaps(node, context, visitMaps, emitMap);
}
/**
 * Uses flavors to find features for a node, using a visit map
 * @param node
 * @param context
 * @param visitMaps
 * @param emitMap
 */
function visitFeaturesWithVisitMaps(node, context, visitMaps, emitMap) {
    var e_1, _a, e_2, _b;
    var _c, _d, _e, _f;
    try {
        for (var _g = __values(context.config.features || []), _h = _g.next(); !_h.done; _h = _g.next()) {
            var feature = _h.value;
            try {
                // Visit all features: always "continue"
                for (var visitMaps_1 = (e_2 = void 0, __values(visitMaps)), visitMaps_1_1 = visitMaps_1.next(); !visitMaps_1_1.done; visitMaps_1_1 = visitMaps_1.next()) {
                    var functionMap = visitMaps_1_1.value;
                    var func = (_c = functionMap) === null || _c === void 0 ? void 0 : _c[feature];
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    var value = (_d = func) === null || _d === void 0 ? void 0 : _d(node, context);
                    if (value != null) {
                        // eslint-disable-next-line @typescript-eslint/no-explicit-any
                        (_f = (_e = emitMap)[feature]) === null || _f === void 0 ? void 0 : _f.call(_e, value);
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (visitMaps_1_1 && !visitMaps_1_1.done && (_b = visitMaps_1.return)) _b.call(visitMaps_1);
                }
                finally { if (e_2) throw e_2.error; }
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_h && !_h.done && (_a = _g.return)) _a.call(_g);
        }
        finally { if (e_1) throw e_1.error; }
    }
    // Visit child nodes
    node.forEachChild(function (child) {
        visitFeaturesWithVisitMaps(child, context, visitMaps, emitMap);
    });
}

/**
 * Merges two jsdocs
 * @param leftJsDoc
 * @param rightJsDoc
 */
function mergeJsDoc(leftJsDoc, rightJsDoc) {
    var _a;
    if (leftJsDoc == null) {
        return rightJsDoc;
    }
    else if (rightJsDoc == null) {
        return leftJsDoc;
    }
    return __assign(__assign({}, ((leftJsDoc !== null && leftJsDoc !== void 0 ? leftJsDoc : rightJsDoc))), { description: (_a = leftJsDoc.description, (_a !== null && _a !== void 0 ? _a : rightJsDoc.description)) });
}
/**
 * Merges modifiers
 * @param leftModifiers
 * @param rightModifiers
 */
function mergeModifiers(leftModifiers, rightModifiers) {
    var _a, _b, _c, _d;
    var newSet = new Set();
    if (((_a = leftModifiers) === null || _a === void 0 ? void 0 : _a.has("static")) && ((_b = rightModifiers) === null || _b === void 0 ? void 0 : _b.has("static"))) {
        newSet.add("static");
    }
    if (((_c = leftModifiers) === null || _c === void 0 ? void 0 : _c.has("readonly")) && ((_d = rightModifiers) === null || _d === void 0 ? void 0 : _d.has("readonly"))) {
        newSet.add("readonly");
    }
    if (newSet.size === 0) {
        return undefined;
    }
    return newSet;
}
/**
 * Merges based on a name
 * @param entries
 * @param direction
 * @param getName
 * @param merge
 */
function mergeNamedEntries(entries, getName, merge) {
    var e_1, _a;
    var merged = new Map();
    try {
        for (var entries_1 = __values(entries), entries_1_1 = entries_1.next(); !entries_1_1.done; entries_1_1 = entries_1.next()) {
            var entry = entries_1_1.value;
            var name_1 = getName(entry);
            var existing = merged.get(name_1);
            if (existing == null) {
                merged.set(name_1, entry);
            }
            else if (merge != null) {
                merged.set(name_1, merge(existing, entry));
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (entries_1_1 && !entries_1_1.done && (_a = entries_1.return)) _a.call(entries_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return Array.from(merged.values());
}

/**
 * Merges multiple slots
 * @param slots
 */
function mergeSlots(slots) {
    return mergeNamedEntries(slots, function (slot) { return slot.name || ""; });
}
/**
 * Merges multiple css parts
 * @param cssParts
 */
function mergeCssParts(cssParts) {
    return mergeNamedEntries(cssParts, function (cssPart) { return cssPart.name; });
}
/**
 * Merges multiple css properties
 * @param cssProps
 */
function mergeCssProperties(cssProps) {
    return mergeNamedEntries(cssProps, function (cssProp) { return cssProp.name; });
}
/**
 * Merges multiple methods
 * @param methods
 */
function mergeMethods(methods) {
    return mergeNamedEntries(methods, function (method) { return method.name; }, function (left, right) { return (__assign(__assign({}, left), { jsDoc: mergeJsDoc(left.jsDoc, right.jsDoc) })); });
    /*return mergeEntries(
        methods,
        (method, mergedMethod) => {
            if (method.name === mergedMethod.name) {
                return (method.modifiers?.has("static") || false) === (mergedMethod.modifiers?.has("static") || false);
            }

            return false;
        },
        (left, right) => ({
            ...left,
            jsDoc: mergeJsDoc(left.jsDoc, right.jsDoc),
            modifiers: mergeModifiers(left.modifiers, right.modifiers)
        })
    );*/
}
/**
 * Merges multiple events
 * @param events
 */
function mergeEvents(events) {
    return mergeNamedEntries(events, function (event) { return event.name; }, function (left, right) { return (__assign(__assign({}, left), { jsDoc: mergeJsDoc(left.jsDoc, right.jsDoc) })); });
}

var priorityValueMap = {
    low: 0,
    medium: 1,
    high: 2
};
/**
 * Merges multiple members based on priority
 * @param memberResults
 * @param context
 */
function mergeMemberResults(memberResults, context) {
    var e_1, _a;
    // Start merging by sorting member results from high to low priority.
    // If two priorities are the same: prioritize the first found element
    // From node 11, equal elements keep their order after sort, but not in node 10
    // Therefore we use "indexOf" to return correct order if two priorities are equal
    memberResults = __spread(memberResults).sort(function (a, b) {
        var vA = priorityValueMap[a.priority];
        var vB = priorityValueMap[b.priority];
        if (vA === vB) {
            var iA = memberResults.indexOf(a);
            var iB = memberResults.indexOf(b);
            return iA < iB ? -1 : 1;
        }
        return vA < vB ? 1 : -1;
    });
    // Keep track of merged props and merged attributes
    // These are stored in maps for speed, because we are going to lookup a member per each memberResult
    var mergeMap = {
        props: new Map(),
        attrs: new Map()
    };
    try {
        // Merge all members one by one adding them to the merge map
        for (var memberResults_1 = __values(memberResults), memberResults_1_1 = memberResults_1.next(); !memberResults_1_1.done; memberResults_1_1 = memberResults_1.next()) {
            var member = memberResults_1_1.value.member;
            // Find a member that is similar to this member
            var mergeableMember = findMemberToMerge(member, mergeMap);
            var newMember = undefined;
            if (mergeableMember == null) {
                // No mergeable member was found, so just add this to the map
                newMember = member;
            }
            else {
                // Remove "member" and "mergeableMember" from the merge map
                // We are going to merge those and add the result to the merge map again
                clearMergeMapWithMember(mergeableMember, mergeMap);
                clearMergeMapWithMember(member, mergeMap);
                newMember = mergeMemberIntoMember(mergeableMember, member, context.checker);
            }
            // Add to merge map
            switch (newMember.kind) {
                case "attribute":
                    mergeMap.attrs.set(newMember.attrName, newMember);
                    break;
                case "property":
                    mergeMap.props.set(newMember.propName, newMember);
                    break;
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (memberResults_1_1 && !memberResults_1_1.done && (_a = memberResults_1.return)) _a.call(memberResults_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    // Return merged results with only "high" priorities
    return __spread(mergeMap.props.values(), mergeMap.attrs.values()).map(function (member) { return ({ priority: "high", member: member }); });
}
/**
 * Removes a member from the merge map
 * @param member
 * @param mergeMap
 */
function clearMergeMapWithMember(member, mergeMap) {
    switch (member.kind) {
        case "attribute":
            mergeMap.attrs.delete(member.attrName);
            break;
        case "property":
            mergeMap.props.delete(member.propName);
            if (member.attrName != null) {
                mergeMap.attrs.delete(member.attrName);
            }
            break;
    }
}
/**
 * Finds a mergeable member
 * @param similar
 * @param mergeMap
 */
function findMemberToMerge(similar, mergeMap) {
    var e_2, _a;
    var attrName = similar.attrName; //?.toLowerCase(); // (similar.kind === "attribute" && similar.attrName.toLowerCase()) || undefined;
    var propName = similar.propName; /*?.toLowerCase()*/ //(similar.kind === "property" && similar.propName.toLowerCase()) || undefined;
    // Return a member that matches either propName (prioritized) or attrName
    if (propName != null) {
        var mergeable = mergeMap.props.get(propName) || mergeMap.attrs.get(propName);
        if (mergeable != null) {
            return mergeable;
        }
    }
    if (attrName != null) {
        var mergeableAttr = mergeMap.attrs.get(attrName);
        if (mergeableAttr != null) {
            return mergeableAttr;
        }
        // Try to find a prop with the attr name.
        // Don't return the prop if it already has an attribute that is not equals to the attr name
        var mergeableProp = mergeMap.props.get(attrName);
        if (mergeableProp != null && mergeableProp.attrName == null) {
            return mergeableProp;
        }
        try {
            for (var _b = __values(mergeMap.props.values()), _c = _b.next(); !_c.done; _c = _b.next()) {
                var mergedAttr = _c.value;
                if (mergedAttr.attrName === attrName) {
                    return mergedAttr;
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_2) throw e_2.error; }
        }
    }
}
/**
 * Merges two members of the same kind into each other.
 * This operation prioritizes leftMember
 * @param leftMember
 * @param rightMember
 * @param checker
 */
function mergeMemberIntoMember(leftMember, rightMember, checker) {
    var _a, _b, _c, _d, _e, _f;
    // Always prioritize merging attribute into property if possible
    if (leftMember.kind === "attribute" && rightMember.kind === "property") {
        return mergeMemberIntoMember(rightMember, leftMember);
    }
    return __assign(__assign({}, leftMember), { attrName: (_a = leftMember.attrName, (_a !== null && _a !== void 0 ? _a : rightMember.attrName)), type: (function () {
            var _a, _b;
            // Always prioritize a "property" over an "attribute" when merging types
            if (leftMember.kind === rightMember.kind || leftMember.kind === "property") {
                return _a = leftMember.type, (_a !== null && _a !== void 0 ? _a : rightMember.type);
            }
            else if (rightMember.kind === "property") {
                return _b = rightMember.type, (_b !== null && _b !== void 0 ? _b : leftMember.type);
            }
        })(), typeHint: (_b = leftMember.typeHint, (_b !== null && _b !== void 0 ? _b : rightMember.typeHint)), jsDoc: mergeJsDoc(leftMember.jsDoc, rightMember.jsDoc), modifiers: mergeModifiers(leftMember.modifiers, rightMember.modifiers), meta: (_c = leftMember.meta, (_c !== null && _c !== void 0 ? _c : rightMember.meta)), default: leftMember.default === undefined ? rightMember.default : leftMember.default, required: (_d = leftMember.required, (_d !== null && _d !== void 0 ? _d : rightMember.required)), visibility: (_e = leftMember.visibility, (_e !== null && _e !== void 0 ? _e : rightMember.visibility)), deprecated: (_f = leftMember.deprecated, (_f !== null && _f !== void 0 ? _f : rightMember.deprecated)) });
}

/**
 * Merges all features in collections of features
 * @param collection
 * @param context
 */
function mergeFeatures(collection, context) {
    if (Array.isArray(collection)) {
        collection = {
            cssParts: arrayFlat(collection.map(function (c) { return c.cssParts; })),
            cssProperties: arrayFlat(collection.map(function (c) { return c.cssProperties; })),
            events: arrayFlat(collection.map(function (c) { return c.events; })),
            memberResults: arrayFlat(collection.map(function (c) { return c.memberResults; })),
            methods: arrayFlat(collection.map(function (c) { return c.methods; })),
            slots: arrayFlat(collection.map(function (c) { return c.slots; }))
        };
        return mergeFeatures(collection, context);
    }
    return {
        cssParts: mergeCssParts(collection.cssParts),
        cssProperties: mergeCssProperties(collection.cssProperties),
        events: mergeEvents(collection.events),
        memberResults: mergeMemberResults(collection.memberResults, context),
        methods: mergeMethods(collection.methods),
        slots: mergeSlots(collection.slots)
    };
}

/**
 * Discovers features for a given node using flavors
 * @param node
 * @param context
 */
function discoverFeatures$1(node, context) {
    // Return the result if we already found this node
    if (context.cache.featureCollection.has(node)) {
        return context.cache.featureCollection.get(node);
    }
    var _a = prepareRefineEmitMap(), collection = _a.collection, refineEmitMap = _a.refineEmitMap;
    // Discovers features for "node" using flavors
    visitFeatures(node, context, {
        event: function (event) { return refineFeature$3("event", event, context, refineEmitMap); },
        member: function (memberResult) { return refineFeature$3("member", memberResult, context, refineEmitMap); },
        csspart: function (cssPart) { return refineFeature$3("csspart", cssPart, context, refineEmitMap); },
        cssproperty: function (cssProperty) { return refineFeature$3("cssproperty", cssProperty, context, refineEmitMap); },
        method: function (method) { return refineFeature$3("method", method, context, refineEmitMap); },
        slot: function (slot) { return refineFeature$3("slot", slot, context, refineEmitMap); }
    });
    // Merge features that were found
    var mergedCollection = mergeFeatures(collection, context);
    // Cache the features for this node
    context.cache.featureCollection.set(node, mergedCollection);
    return mergedCollection;
}

/**
 * Executes functions in a function map until some function returns a non-undefined value.
 * @param functionMaps
 * @param keys
 * @param arg
 * @param context
 */
function executeFunctionsUntilMatch(functionMaps, keys, arg, context) {
    var e_1, _a, e_2, _b;
    keys = Array.isArray(keys) ? keys : [keys];
    try {
        for (var keys_1 = __values(keys), keys_1_1 = keys_1.next(); !keys_1_1.done; keys_1_1 = keys_1.next()) {
            var key = keys_1_1.value;
            var _loop_1 = function (functionMap) {
                var func = functionMap[key];
                if (func == null)
                    return "continue";
                // Save a "continue" flag if necessary
                var shouldContinue = false;
                var result = func(arg, __assign(__assign({}, context), { emitContinue: function () {
                        shouldContinue = true;
                    } }));
                // Return a result if not undefined
                if (result != null) {
                    return { value: { value: result, shouldContinue: shouldContinue } };
                }
            };
            try {
                // Loop through each function
                for (var functionMaps_1 = (e_2 = void 0, __values(functionMaps)), functionMaps_1_1 = functionMaps_1.next(); !functionMaps_1_1.done; functionMaps_1_1 = functionMaps_1.next()) {
                    var functionMap = functionMaps_1_1.value;
                    var state_1 = _loop_1(functionMap);
                    if (typeof state_1 === "object")
                        return state_1.value;
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (functionMaps_1_1 && !functionMaps_1_1.done && (_b = functionMaps_1.return)) _b.call(functionMaps_1);
                }
                finally { if (e_2) throw e_2.error; }
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (keys_1_1 && !keys_1_1.done && (_a = keys_1.return)) _a.call(keys_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return undefined;
}

/**
 * Uses flavors to find inheritance for a node
 * @param node
 * @param context
 * @param emit
 * @param visitSet
 */
function visitInheritance(node, context, emit, visitSet) {
    visitSet = visitSet || new Set();
    if (visitSet.has(node)) {
        return;
    }
    visitSet.add(node);
    // Discover inheritance tree clauses for a given node
    var result = executeFunctionsUntilMatch(context.flavors, "discoverInheritance", node, context);
    if (result != null) {
        // Emit the found inheritance tree clauses and expand them! (walk down the inheritance tree)
        emit(result.value.map(function (link) { return visitAndExpandInheritClause(link, context, visitSet); }));
        if (!result.shouldContinue)
            return;
    }
}
/**
 * Uses flavors to find inheritance for a node
 * This function expands an inherit clause by visiting inheritance on the resolved node.
 * @param inheritClause
 * @param context
 * @param visitSet
 */
function visitAndExpandInheritClause(inheritClause, context, visitSet) {
    var _a;
    var resolved = (function () {
        if (inheritClause.resolved == null)
            return undefined;
        // Find the inheritance on the resolved node and built up an inheritance tree node
        return inheritClause.resolved.map(function (resolved) {
            var inheritance = [];
            visitInheritance(resolved.node, context, function (results) {
                inheritance = inheritance.concat(results);
            }, visitSet);
            return __assign(__assign({}, resolved), { inherits: inheritance });
        });
    })();
    return __assign(__assign({}, inheritClause), { 
        // Expand the horizontal inheritance (mixins)
        horizontalInherits: (_a = inheritClause.horizontalInherits) === null || _a === void 0 ? void 0 : _a.map(function (arg) { return visitAndExpandInheritClause(arg, context, visitSet); }), resolved: resolved });
}

/**
 * Uses flavors in order to discover inheritance from one of more nodes.
 * @param startNode
 * @param context
 */
function discoverInheritance$1(startNode, context) {
    var e_1, _a;
    var nodes = Array.isArray(startNode) ? startNode : [startNode];
    var mainNode = nodes[0];
    var inherits = [];
    try {
        for (var nodes_1 = __values(nodes), nodes_1_1 = nodes_1.next(); !nodes_1_1.done; nodes_1_1 = nodes_1.next()) {
            var node = nodes_1_1.value;
            // Visit inheritance using flavors
            visitInheritance(node, context, function (link) {
                inherits = inherits.concat(link);
            });
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (nodes_1_1 && !nodes_1_1.done && (_a = nodes_1.return)) _a.call(nodes_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return {
        node: mainNode,
        identifier: getDeclarationIdentifier(mainNode, context),
        inherits: inherits
    };
}

/**
 * Uses flavors to determine if a node should be excluded from the output
 * @param node
 * @param context
 */
function excludeNode$2(node, context) {
    var e_1, _a;
    var _b, _c;
    try {
        for (var _d = __values(context.flavors), _e = _d.next(); !_e.done; _e = _d.next()) {
            var flavor = _e.value;
            var exclude = (_c = (_b = flavor).excludeNode) === null || _c === void 0 ? void 0 : _c.call(_b, node, context);
            if (exclude) {
                return true;
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return false;
}

/**
 * Uses flavors to refine a declaration
 * @param declaration
 * @param context
 */
function refineDeclaration$1(declaration, context) {
    var e_1, _a;
    var _b, _c, _d;
    try {
        for (var _e = __values(context.flavors), _f = _e.next(); !_f.done; _f = _e.next()) {
            var flavor = _f.value;
            declaration = (_d = (_c = (_b = flavor).refineDeclaration) === null || _c === void 0 ? void 0 : _c.call(_b, declaration, context), (_d !== null && _d !== void 0 ? _d : declaration));
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_f && !_f.done && (_a = _e.return)) _a.call(_e);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return declaration;
}

/**
 * Discovers features on component declaration nodes
 * @param initialDeclarationNodes
 * @param context
 */
function analyzeComponentDeclaration(initialDeclarationNodes, context) {
    var e_1, _a, e_2, _b;
    var mainDeclarationNode = initialDeclarationNodes[0];
    if (mainDeclarationNode == null) {
        throw new Error("Couldn't find main declaration node");
    }
    // Discover the inheritance tree
    var inheritanceTree = discoverInheritance$1(initialDeclarationNodes, context);
    // Find unique resolved nodes in the inheritance tree
    var declarationNodes = getUniqueResolvedNodeForInheritanceTree(inheritanceTree);
    try {
        // Add initial declaration nodes to the set (nodes that aren't the main declaration node)
        for (var initialDeclarationNodes_1 = __values(initialDeclarationNodes), initialDeclarationNodes_1_1 = initialDeclarationNodes_1.next(); !initialDeclarationNodes_1_1.done; initialDeclarationNodes_1_1 = initialDeclarationNodes_1.next()) {
            var node = initialDeclarationNodes_1_1.value;
            if (node !== mainDeclarationNode) {
                declarationNodes.add(node);
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (initialDeclarationNodes_1_1 && !initialDeclarationNodes_1_1.done && (_a = initialDeclarationNodes_1.return)) _a.call(initialDeclarationNodes_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    var featureCollections = [];
    var baseDeclaration = {
        events: [],
        cssParts: [],
        cssProperties: [],
        members: [],
        methods: [],
        slots: [],
        jsDoc: getJsDoc(mainDeclarationNode, context.ts),
        inheritanceTree: inheritanceTree,
        declarationNodes: declarationNodes
    };
    // Add the "get declaration" hook to the context
    context = __assign(__assign({}, context), { getDeclaration: function () { return baseDeclaration; } });
    try {
        // Find features on all declaration nodes
        for (var declarationNodes_1 = __values(declarationNodes), declarationNodes_1_1 = declarationNodes_1.next(); !declarationNodes_1_1.done; declarationNodes_1_1 = declarationNodes_1.next()) {
            var node = declarationNodes_1_1.value;
            if (shouldExcludeNode(node, context)) {
                continue;
            }
            // Discover component features using flavors
            featureCollections.push(discoverFeatures$1(node, __assign(__assign({}, context), { declarationNode: node })));
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (declarationNodes_1_1 && !declarationNodes_1_1.done && (_b = declarationNodes_1.return)) _b.call(declarationNodes_1);
        }
        finally { if (e_2) throw e_2.error; }
    }
    // If all nodes were excluded, return empty declaration
    if (featureCollections.length === 0) {
        return baseDeclaration;
    }
    // Merge all features into one single collection prioritizing features found in first
    var mergedFeatureCollection = featureCollections.length > 1 ? mergeFeatures(featureCollections, context) : featureCollections[0];
    // Refine the declaration and return the result
    return refineDeclaration$1(__assign(__assign({}, baseDeclaration), { cssParts: mergedFeatureCollection.cssParts, cssProperties: mergedFeatureCollection.cssProperties, events: mergedFeatureCollection.events, methods: mergedFeatureCollection.methods, members: mergedFeatureCollection.memberResults.map(function (_a) {
            var member = _a.member;
            return member;
        }), slots: mergedFeatureCollection.slots }), context);
}
/**
 * Returns if a node should be excluded from the analyzing
 * @param node
 * @param context
 */
function shouldExcludeNode(node, context) {
    var _a;
    // Uses flavors to determine if the node should be excluded
    if (excludeNode$2(node, context)) {
        return true;
    }
    // It's possible to exclude declaration names
    var name = getDeclarationName(node, context);
    if (name != null && ((_a = context.config.excludedDeclarationNames) === null || _a === void 0 ? void 0 : _a.includes(name))) {
        return true;
    }
    return false;
}

/**
 * Uses flavors to visit definitions
 * @param node
 * @param context
 * @param emit
 */
function visitDefinitions(node, context, emit) {
    var result = executeFunctionsUntilMatch(context.flavors, "discoverDefinitions", node, context);
    if (result != null) {
        emit(result.value);
        if (!result.shouldContinue)
            return;
    }
    // Visit child nodes
    node.forEachChild(function (child) {
        visitDefinitions(child, context, emit);
    });
}

/**
 * Visits the source file and finds all component definitions using flavors
 * @param sourceFile
 * @param context
 * @param analyzeDeclaration
 */
function discoverDefinitions$4(sourceFile, context, analyzeDeclaration) {
    // Find all definitions in the file using flavors
    var definitionResults = analyzeAndDedupeDefinitions(sourceFile, context);
    return Array.from(definitionResults.entries()).map(function (_a) {
        var _b = __read(_a, 2), definition = _b[0], declarationSet = _b[1];
        return __assign(__assign({}, definition), { declaration: lazy(function () { return analyzeDeclaration(definition, Array.from(declarationSet)); }) });
    });
}
/**
 * Finds all component definitions in a file and combine multiple declarations with same tag name.
 * @param node
 * @param context
 */
function analyzeAndDedupeDefinitions(node, context) {
    var e_1, _a, e_2, _b;
    if (node == null)
        return new Map();
    // Keep a map of "tag name" ==> "definition"
    var tagNameDefinitionMap = new Map();
    // Keep a map of "definition" ==> "declaration nodes"
    var definitionToDeclarationMap = new Map();
    // Discover definitions using flavors
    visitDefinitions(node, context, function (results) {
        var e_3, _a;
        try {
            // Definitions are unique by tag name and are merged when pointing to multiple declaration nodes.
            // This is because multiple definitions can exist side by side for the same tag name (think global TagName type definition and customElements.define)
            for (var results_3 = __values(results), results_3_1 = results_3.next(); !results_3_1.done; results_3_1 = results_3.next()) {
                var result = results_3_1.value;
                // Find existing definition with the result name
                var definition = tagNameDefinitionMap.get(result.tagName);
                if (definition == null) {
                    // No existing definition was found, - create one!
                    definition = {
                        declaration: function () {
                            throw new Error("This is a noop function. It's expected that this function is overwritten.");
                        },
                        tagName: result.tagName,
                        tagNameNodes: new Set(),
                        identifierNodes: new Set()
                    };
                    tagNameDefinitionMap.set(result.tagName, definition);
                }
                // Add the discovered identifier node to the definition
                if (result.identifierNode != null) {
                    definition.identifierNodes.add(result.identifierNode);
                }
                // Add the discovered tag name node to the definition
                if (result.tagNameNode) {
                    definition.tagNameNodes.add(result.tagNameNode);
                }
                // Add the discovered declaration node to the map from "definition" ==> "declaration nodes"
                var declarationNodeSet = definitionToDeclarationMap.get(definition);
                if (declarationNodeSet == null) {
                    declarationNodeSet = new Set();
                    definitionToDeclarationMap.set(definition, declarationNodeSet);
                }
                declarationNodeSet.add(result.declarationNode);
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (results_3_1 && !results_3_1.done && (_a = results_3.return)) _a.call(results_3);
            }
            finally { if (e_3) throw e_3.error; }
        }
    });
    // Remove duplicates where "tagName" is equals to "" if the declaration node is not used in any other definition.
    var results = Array.from(definitionToDeclarationMap.entries());
    try {
        for (var results_1 = __values(results), results_1_1 = results_1.next(); !results_1_1.done; results_1_1 = results_1.next()) {
            var _c = __read(results_1_1.value, 2), definition = _c[0], declarations = _c[1];
            if (definition.tagName === "") {
                var _loop_1 = function (checkDefinition, checkDeclarations) {
                    // Find duplicated based on overlapping declarations
                    if (definition !== checkDefinition && Array.from(declarations).find(function (decl) { return checkDeclarations.has(decl) != null; })) {
                        definitionToDeclarationMap.delete(definition);
                        return "break";
                    }
                };
                try {
                    for (var results_2 = (e_2 = void 0, __values(results)), results_2_1 = results_2.next(); !results_2_1.done; results_2_1 = results_2.next()) {
                        var _d = __read(results_2_1.value, 2), checkDefinition = _d[0], checkDeclarations = _d[1];
                        var state_1 = _loop_1(checkDefinition, checkDeclarations);
                        if (state_1 === "break")
                            break;
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (results_2_1 && !results_2_1.done && (_b = results_2.return)) _b.call(results_2);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (results_1_1 && !results_1_1.done && (_a = results_1.return)) _a.call(results_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return definitionToDeclarationMap;
}

/**
 * Uses flavors to find global features
 * @param node
 * @param context
 * @param emitMap
 */
function visitGlobalFeatures(node, context, emitMap) {
    var visitMaps = arrayDefined(context.flavors.map(function (flavor) { return flavor.discoverGlobalFeatures; }));
    visitFeaturesWithVisitMaps(node, context, visitMaps, emitMap);
}

/**
 * Discover all global features using flavors
 * @param node
 * @param context
 */
function discoverGlobalFeatures$3(node, context) {
    var _a = prepareRefineEmitMap(), collection = _a.collection, refineEmitMap = _a.refineEmitMap;
    // Discovers global features using flavors
    visitGlobalFeatures(node, context, {
        event: function (event) { return refineFeature$3("event", event, context, refineEmitMap); },
        member: function (memberResult) { return refineFeature$3("member", memberResult, context, refineEmitMap); },
        csspart: function (cssPart) { return refineFeature$3("csspart", cssPart, context, refineEmitMap); },
        cssproperty: function (cssProperty) { return refineFeature$3("cssproperty", cssProperty, context, refineEmitMap); },
        method: function (method) { return refineFeature$3("method", method, context, refineEmitMap); },
        slot: function (slot) { return refineFeature$3("slot", slot, context, refineEmitMap); }
    });
    // Merge features in the collection
    var mergedFeatures = mergeFeatures(collection, context);
    return __assign(__assign({}, mergedFeatures), { members: mergedFeatures.memberResults.map(function (res) { return res.member; }) });
}

/**
 * Analyzes all components in a source file.
 * @param sourceFile
 * @param options
 */
function analyzeSourceFile(sourceFile, options) {
    // Create a new context
    var context = makeContextFromConfig(options);
    // Analyze all components
    var componentDefinitions = discoverDefinitions$4(sourceFile, context, function (definition, declarationNodes) {
        // The component declaration is analyzed lazily
        return analyzeComponentDeclaration(declarationNodes, __assign(__assign({}, context), { getDeclaration: definition.declaration, getDefinition: function () { return definition; } }));
    });
    // Analyze global features
    var globalFeatures = undefined;
    if (context.config.analyzeGlobalFeatures) {
        globalFeatures = discoverGlobalFeatures$3(sourceFile, context);
    }
    return {
        sourceFile: sourceFile,
        componentDefinitions: componentDefinitions,
        globalFeatures: globalFeatures
    };
}

function isTypescriptNode(value) {
    return value instanceof Object && "kind" in value && "flags" in value;
}
function isTypescriptSourceFile(value) {
    return value instanceof Object && "kind" in value && "fileName" in value;
}
function isTypescriptType(value) {
    return value instanceof Object && "flags" in value && "checker" in value;
}
function isSimpleType(value) {
    return value instanceof Object && "kind" in value && Object.values(SimpleTypeKind).includes(value.kind);
}
/**
 * Returns a representation of the input that can be JSON stringified
 */
function stripTypescriptValues(input, checker) {
    var e_1, _a;
    var _b, _c, _d, _e, _f;
    if (input == null) {
        return input;
    }
    else if (typeof input === "function") {
        return stripTypescriptValues(input(), checker);
    }
    else if (isTypescriptSourceFile(input)) {
        return "{SOURCEFILE:" + ((_b = input.fileName.match(".*/(.+)")) === null || _b === void 0 ? void 0 : _b[1]) + "}";
    }
    else if (isTypescriptNode(input)) {
        var title = "escapedText" in input ? input.escapedText : undefined;
        return "{NODE:" + ((_f = (_e = (_d = (_c = input).getSourceFile) === null || _d === void 0 ? void 0 : _d.call(_c)) === null || _e === void 0 ? void 0 : _e.fileName.match(".*/(.+)")) === null || _f === void 0 ? void 0 : _f[1]) + (title != null ? ":" + title : "") + ":" + input.pos + "}";
    }
    else if (isTypescriptType(input)) {
        if (checker == null) {
            return "{TYPE}";
        }
        return "{TYPE:" + checker.typeToString(input) + "}";
    }
    else if (isSimpleType(input)) {
        return "{SIMPLE_TYPE:" + toTypeString(input) + "}";
    }
    else if (Array.isArray(input)) {
        return input.map(function (i) { return stripTypescriptValues(i, checker); });
    }
    else if (input instanceof Set) {
        return stripTypescriptValues(Array.from(input), checker);
    }
    else if (input instanceof Map) {
        return stripTypescriptValues(Array.from(input), checker);
    }
    else if (input instanceof Object) {
        var obj = {};
        try {
            for (var _g = __values(Object.entries(input)), _h = _g.next(); !_h.done; _h = _g.next()) {
                var _j = __read(_h.value, 2), key = _j[0], value = _j[1];
                var strippedValue = stripTypescriptValues(value, checker);
                if (strippedValue !== undefined && (!Array.isArray(strippedValue) || strippedValue.length > 0)) {
                    obj[key] = strippedValue;
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_h && !_h.done && (_a = _g.return)) _a.call(_g);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return obj;
    }
    return input;
}

/**
 * Transforms results to json.
 * @param results
 * @param program
 * @param config
 */
var debugJsonTransformer = function (results, program, config) {
    var definitions = arrayFlat(results.map(function (res) { return res.componentDefinitions; }));
    return JSON.stringify(stripTypescriptValues(definitions, program.getTypeChecker()), null, 2);
};

/**
 * Returns a "type hint" from a type
 * The type hint is an easy to read representation of the type and is not made for being parsed.
 * @param type
 * @param checker
 */
function getTypeHintFromType(type, checker) {
    if (type == null)
        return undefined;
    if (typeof type === "string")
        return type;
    var typeHint = toTypeString(type, checker);
    // Replace "anys" and "{}" with more human friendly representations
    if (typeHint === "any")
        return undefined;
    if (typeHint === "any[]")
        return "array";
    if (typeHint === "{}")
        return "object";
    return typeHint;
}

var VISIBILITY_NUMBER_MAP = {
    private: 1,
    protected: 2,
    public: 3
};
/**
 * Removes all items from an array with visibilities that are less visible than "visibility".
 * @param visibility
 * @param array
 */
function filterVisibility(visibility, array) {
    var target = VISIBILITY_NUMBER_MAP[visibility];
    return array.filter(function (item) { return VISIBILITY_NUMBER_MAP[item.visibility || "public"] >= target; });
}

/**
 * Returns the first element in the set
 * @param set
 */
function getFirst(set) {
    return set.values().next().value;
}

/**
 * Transforms results to json.
 * @param results
 * @param program
 * @param config
 */
var jsonTransformer = function (results, program, config) {
    var checker = program.getTypeChecker();
    // Get all definitions
    var definitions = arrayFlat(results.map(function (res) { return res.componentDefinitions; }));
    // Transform all definitions into "tags"
    var tags = definitions.map(function (d) { return definitionToHtmlDataTag(d, checker, config); });
    var htmlData = {
        version: "experimental",
        tags: tags
    };
    return JSON.stringify(htmlData, null, 2);
};
function definitionToHtmlDataTag(definition, checker, config) {
    var _a;
    var declaration = definition.declaration();
    // Grab path to the definition file if possible
    var node = getFirst(definition.tagNameNodes) || getFirst(definition.identifierNodes);
    var fileName = (_a = node) === null || _a === void 0 ? void 0 : _a.getSourceFile().fileName;
    var path = fileName != null && config.cwd != null ? "./" + relative(config.cwd, fileName) : undefined;
    var attributes = arrayDefined(filterVisibility(config.visibility, declaration.members).map(function (d) { return componentMemberToHtmlDataAttribute(d, checker); }));
    var properties = arrayDefined(filterVisibility(config.visibility, declaration.members).map(function (d) { return componentMemberToHtmlDataProperty(d, checker); }));
    var events = arrayDefined(filterVisibility(config.visibility, declaration.events).map(function (e) { return componentEventToHtmlDataEvent(e); }));
    var slots = arrayDefined(declaration.slots.map(function (e) { return componentSlotToHtmlDataSlot(e); }));
    var cssProperties = arrayDefined(declaration.cssProperties.map(function (p) { return componentCssPropToHtmlCssProp(p); }));
    var cssParts = arrayDefined(declaration.cssParts.map(function (p) { return componentCssPartToHtmlCssPart(p); }));
    return {
        name: definition.tagName,
        path: path,
        description: getDescriptionFromJsDoc(declaration.jsDoc),
        attributes: attributes.length === 0 ? undefined : attributes,
        properties: properties.length === 0 ? undefined : properties,
        events: events.length === 0 ? undefined : events,
        slots: slots.length === 0 ? undefined : slots,
        cssProperties: cssProperties.length === 0 ? undefined : cssProperties,
        cssParts: cssParts.length === 0 ? undefined : cssParts,
        deprecated: declaration.deprecated === true || typeof declaration.deprecated === "string" || undefined,
        deprecatedMessage: typeof declaration.deprecated === "string" ? declaration.deprecated : undefined
    };
}
function componentCssPropToHtmlCssProp(prop, checker) {
    return {
        name: prop.name || "",
        description: getDescriptionFromJsDoc(prop.jsDoc),
        type: prop.typeHint,
        default: prop.default != null ? JSON.stringify(prop.default) : undefined
    };
}
function componentCssPartToHtmlCssPart(part, checker) {
    return {
        name: part.name || "",
        description: getDescriptionFromJsDoc(part.jsDoc)
    };
}
function componentSlotToHtmlDataSlot(slot, checker) {
    return {
        name: slot.name || "",
        description: getDescriptionFromJsDoc(slot.jsDoc)
    };
}
function componentEventToHtmlDataEvent(event, checker) {
    return {
        name: event.name,
        description: getDescriptionFromJsDoc(event.jsDoc),
        deprecated: event.deprecated === true || undefined,
        deprecatedMessage: typeof event.deprecated === "string" ? event.deprecated : undefined
    };
}
function componentMemberToHtmlDataAttribute(member, checker) {
    var _a, _b, _c;
    if (member.attrName == null) {
        return undefined;
    }
    return {
        name: member.attrName,
        description: getDescriptionFromJsDoc(member.jsDoc),
        type: getTypeHintFromType((_a = member.typeHint, (_a !== null && _a !== void 0 ? _a : (_c = (_b = member).type) === null || _c === void 0 ? void 0 : _c.call(_b))), checker),
        default: member.default != null ? JSON.stringify(member.default) : undefined,
        deprecated: member.deprecated === true || undefined,
        deprecatedMessage: typeof member.deprecated === "string" ? member.deprecated : undefined
    };
}
function componentMemberToHtmlDataProperty(member, checker) {
    var _a, _b, _c;
    if (member.propName == null) {
        return undefined;
    }
    return {
        name: member.propName,
        attribute: member.attrName,
        description: getDescriptionFromJsDoc(member.jsDoc),
        type: getTypeHintFromType((_a = member.typeHint, (_a !== null && _a !== void 0 ? _a : (_c = (_b = member).type) === null || _c === void 0 ? void 0 : _c.call(_b))), checker),
        default: member.default != null ? JSON.stringify(member.default) : undefined,
        deprecated: member.deprecated === true || undefined,
        deprecatedMessage: typeof member.deprecated === "string" ? member.deprecated : undefined
    };
}
function getDescriptionFromJsDoc(jsDoc) {
    var _a;
    return (_a = jsDoc) === null || _a === void 0 ? void 0 : _a.description;
}

/**
 * Parses and returns examples for a component.
 * @param declaration
 */
function getExamplesFromComponent(declaration) {
    var _a, _b;
    var examples = ((_b = (_a = declaration.jsDoc) === null || _a === void 0 ? void 0 : _a.tags) === null || _b === void 0 ? void 0 : _b.filter(function (tag) { return tag.tag === "example" || tag.tag === "demo"; })) || [];
    return examples.map(exampleFromJsDocTag);
}
/**
 * Returns an example based on a jsdoc tag
 * @param tag
 */
function exampleFromJsDocTag(tag) {
    var _a = discoverCodeFromExampleText(tag.comment || ""), code = _a.code, lang = _a.lang, description = _a.description;
    return {
        lang: lang,
        description: description,
        code: code
    };
}
/**
 * Parses some text and returns the first found example
 * @param text
 */
function discoverCodeFromExampleText(text) {
    // Check if there is a code example already like this: ```code here ```
    var escapedCodeMatch = text.match(/([\s\S]*)```(\S*)([\s\S]+)```/);
    if (escapedCodeMatch != null) {
        return {
            description: (escapedCodeMatch[1] || "").trim() || undefined,
            lang: escapedCodeMatch[2] || undefined,
            code: (escapedCodeMatch[3] || "").trim()
        };
    }
    // Else, assume that the text is the code
    return { code: text.trim(), lang: discoverLanguageFromExampleText(text) };
}
/**
 * Returns the language of some code based on assumptions
 * @param code
 */
function discoverLanguageFromExampleText(code) {
    if (code.includes("html`")) {
        return "javascript";
    }
    if (code.match(/<\S/)) {
        return "html";
    }
    return "javascript";
}

/**
 * This method returns a "type hint" that represents the method signature
 * The resulting type takes jsdoc into account.
 * I couldn't find a way for Typescript to return the signature string taking jsdoc into account
 *   so therefore I had to do some regex-magic in this method.
 */
function getTypeHintFromMethod(method, checker) {
    var e_1, _a;
    var _b, _c, _d, _e, _f, _g, _h, _j;
    var signature = getTypeHintFromType((_c = (_b = method).type) === null || _c === void 0 ? void 0 : _c.call(_b), checker) || "";
    // Replace "=>" with ":" and the return type with the returnTypeHint if present
    signature = signature.replace(/\)\s*=>\s?(.*)$/, "): " + (_g = (_f = (_e = (_d = method.jsDoc) === null || _d === void 0 ? void 0 : _d.tags) === null || _e === void 0 ? void 0 : _e.find(function (tag) { return ["returns", "return"].includes(tag.tag); })) === null || _f === void 0 ? void 0 : _f.parsed().type, (_g !== null && _g !== void 0 ? _g : "$1")));
    try {
        // Replace all "any" types with corresponding type hints
        for (var _k = __values(((_j = (_h = method.jsDoc) === null || _h === void 0 ? void 0 : _h.tags) === null || _j === void 0 ? void 0 : _j.filter(function (tag) { return tag.tag === "param"; })) || []), _l = _k.next(); !_l.done; _l = _k.next()) {
            var parameterJsDocTag = _l.value;
            var parsed = parameterJsDocTag.parsed();
            if (parsed.type != null) {
                signature = signature.replace(new RegExp(parsed.name + "(.*?:\\s*)any\\[?]?"), parsed.name + "$1" + parsed.type);
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_l && !_l.done && (_a = _k.return)) _a.call(_k);
        }
        finally { if (e_1) throw e_1.error; }
    }
    // Replace "{}" with more pleasant string
    signature = signature.replace("{}", "object");
    return signature;
}

/**
 * Returns a markdown header with a specific level taking global start title level into account.
 * @param title
 * @param level
 * @param config
 */
function markdownHeader(title, level, config) {
    var _a, _b;
    level = level - 1 + (((_a = config.markdown) === null || _a === void 0 ? void 0 : _a.headerLevel) || ((_b = config.markdown) === null || _b === void 0 ? void 0 : _b.titleLevel) || 1);
    return "#".repeat(level) + " " + title;
}
/**
 * Returns a markdown table representation of the rows.
 * Strips unused columns.
 * @param rows
 * @param removeEmptyColumns
 */
function markdownTable(rows, _a) {
    var removeEmptyColumns = (_a === void 0 ? { removeEmptyColumns: true } : _a).removeEmptyColumns;
    // Constants for pretty printing the markdown tables
    var MIN_CELL_WIDTH = 3;
    var MAX_CELL_WIDTH = 50;
    var CELL_PADDING = 1;
    // Count the number of columns
    var columnCount = Math.max.apply(Math, __spread(rows.map(function (r) { return r.length; })));
    if (removeEmptyColumns) {
        // Create a boolean array where each entry tells if a column is used or not (excluding the header)
        var emptyColumns_1 = Array(columnCount)
            .fill(false)
            .map(function (b, i) { return i !== 0 && rows.slice(1).find(function (r) { return r[i] != null && r[i].length > 0; }) == null; });
        // Remove unused columns if necessary
        if (emptyColumns_1.includes(true)) {
            // Filter out the unused columns in each row
            rows = rows.map(function (row) { return row.filter(function (column, i) { return !emptyColumns_1[i]; }); });
            // Adjust the column count
            columnCount = Math.max.apply(Math, __spread(rows.map(function (r) { return r.length; })));
        }
    }
    // Escape all cells in the markdown output
    rows = rows.map(function (r) { return r.map(markdownEscapeTableCell); });
    // Create a boolean array where each entry corresponds to the preferred column width.
    // This is done by taking the largest width of all cells in each column.
    var columnWidths = Array(columnCount)
        .fill(0)
        .map(function (c, i) { return Math.min(MAX_CELL_WIDTH, Math.max.apply(Math, __spread([MIN_CELL_WIDTH], rows.map(function (r) { return (r[i] || "").length; }))) + CELL_PADDING * 2); });
    // Build up the table
    return "\n|" + rows[0].map(function (r, i) { return fillWidth(r, columnWidths[i], CELL_PADDING); }).join("|") + "|\n|" + columnWidths.map(function (c) { return "-".repeat(c); }).join("|") + "|\n" + rows
        .slice(1)
        .map(function (r) { return "|" + r.map(function (r, i) { return fillWidth(r, columnWidths[i], CELL_PADDING); }).join("|") + "|"; })
        .join("\n") + "\n";
}
/**
 * Escape a text so it can be used in a markdown table
 * @param text
 */
function markdownEscapeTableCell(text) {
    return text.replace(/\n/g, "<br />").replace(/\|/g, "\\|");
}
/**
 * Highlights some text
 * @param text
 */
function markdownHighlight(text) {
    if (text == null || text.length === 0)
        return "";
    return "`" + text + "`";
}
/**
 * Creates padding around some text with a target width.
 * @param text
 * @param width
 * @param paddingStart
 */
function fillWidth(text, width, paddingStart) {
    return " ".repeat(paddingStart) + text + " ".repeat(Math.max(1, width - text.length - paddingStart));
}

/**
 * Transforms the component results to markdown
 * @param results
 * @param program
 * @param config
 */
var markdownTransformer = function (results, program, config) {
    // Grab all definitions
    var definitions = arrayFlat(results.map(function (res) { return res.componentDefinitions; }));
    // Transform all definitions to markdown
    var markdownSegments = definitions.map(function (definition) {
        var e_1, _a;
        var _b, _c;
        var declaration = definition.declaration();
        // Add tagName as header
        var segmentText = markdownHeader(definition.tagName, 1, config) + "\n";
        // Add component jsdoc comment to the output
        if (((_b = declaration.jsDoc) === null || _b === void 0 ? void 0 : _b.description) != null)
            segmentText += "\n" + ((_c = declaration.jsDoc) === null || _c === void 0 ? void 0 : _c.description) + "\n";
        // Add mixins (don't include mixins prefixed with _)
        var mixins = Array.from(getMixinsForInheritanceTree(declaration.inheritanceTree).values()).filter(function (mixin) { return !mixin.startsWith("_"); });
        if (mixins.length > 0) {
            segmentText += "\n**Mixins:** " + mixins.join(", ") + "\n";
        }
        // Add examples
        var examples = getExamplesFromComponent(declaration);
        if (examples.length > 0) {
            segmentText += "\n" + markdownHeader("Example" + (examples.length > 1 ? "s" : ""), 2, config) + "\n";
            try {
                for (var examples_1 = __values(examples), examples_1_1 = examples_1.next(); !examples_1_1.done; examples_1_1 = examples_1.next()) {
                    var example = examples_1_1.value;
                    if (example.description != null) {
                        segmentText += "\n" + example.description + "\n";
                    }
                    segmentText += "\n```" + (example.lang || "") + "\n" + example.code + "\n```\n";
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (examples_1_1 && !examples_1_1.done && (_a = examples_1.return)) _a.call(examples_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
        // Grab all items from the component and add them as tables to the output.
        var properties = filterVisibility(config.visibility, declaration.members.filter(function (m) { return m.kind === "property"; }).sort(function (a, b) { return (a.propName < b.propName ? -1 : 1); }));
        var attributes = filterVisibility(config.visibility, declaration.members.filter(function (m) { return m.kind === "attribute"; }).sort(function (a, b) { return (a.attrName < b.attrName ? -1 : 1); }));
        var methods = filterVisibility(config.visibility, declaration.methods.sort(function (a, b) { return (a.name < b.name ? -1 : 1); }));
        var slots = declaration.slots.sort(function (a, b) { return (a.name == null ? -1 : b.name == null ? 1 : a.name < b.name ? -1 : 1); });
        var events = declaration.events.sort(function (a, b) { return (a.name < b.name ? -1 : 1); });
        var cssProps = declaration.cssProperties.sort(function (a, b) { return (a.name < b.name ? -1 : 1); });
        var cssParts = declaration.cssParts.sort(function (a, b) { return (a.name < b.name ? -1 : 1); });
        if (attributes.length > 0) {
            segmentText += "\n" + memberAttributeSection(attributes, program.getTypeChecker(), config);
        }
        if (properties.length > 0) {
            segmentText += "\n" + memberPropertySection(properties, program.getTypeChecker(), config);
        }
        if (methods.length > 0) {
            segmentText += "\n" + methodSection(methods, program.getTypeChecker(), config);
        }
        if (events.length > 0) {
            segmentText += "\n" + eventSection(events, program.getTypeChecker(), config);
        }
        if (slots.length > 0) {
            segmentText += "\n" + slotSection(slots, config);
        }
        if (cssParts.length > 0) {
            segmentText += "\n" + cssPartSection(cssParts, config);
        }
        if (cssProps.length > 0) {
            segmentText += "\n" + cssPropSection(cssProps, config);
        }
        return segmentText;
    });
    return markdownSegments.join("\n\n");
};
/**
 * Returns a markdown table with css props
 * @param cssProperties
 * @param config
 */
function cssPropSection(cssProperties, config) {
    var rows = [["Property", "Type", "Default", "Description"]];
    rows.push.apply(rows, __spread(cssProperties.map(function (prop) {
        var _a;
        var def = (prop.default !== undefined ? JSON.stringify(prop.default) : "") || "";
        return [(prop.name && markdownHighlight(prop.name)) || "", prop.typeHint || "", def, ((_a = prop.jsDoc) === null || _a === void 0 ? void 0 : _a.description) || ""];
    })));
    return markdownHeader("CSS Custom Properties", 2, config) + "\n" + markdownTable(rows);
}
/**
 * Returns a markdown table with css parts
 * @param cssPart
 * @param config
 */
function cssPartSection(cssPart, config) {
    var rows = [["Part", "Description"]];
    rows.push.apply(rows, __spread(cssPart.map(function (part) { var _a; return [(part.name && markdownHighlight(part.name)) || "", ((_a = part.jsDoc) === null || _a === void 0 ? void 0 : _a.description) || ""]; })));
    return markdownHeader("CSS Shadow Parts", 2, config) + "\n" + markdownTable(rows);
}
/**
 * Returns a markdown table with methods
 * @param methods
 * @param checker
 * @param config
 */
function methodSection(methods, checker, config) {
    var showVisibility = shouldShowVisibility(methods, config);
    var rows = [["Method", "Visibility", "Type", "Description"]];
    rows.push.apply(rows, __spread(methods.map(function (method) {
        var _a, _b, _c;
        // Build up a description of parameters
        var paramDescription = ((_b = (_a = method.jsDoc) === null || _a === void 0 ? void 0 : _a.tags) === null || _b === void 0 ? void 0 : _b.filter(function (tag) { return tag.tag === "param" && tag.comment != null; }).map(function (tag) {
            return "**" + tag.parsed().name + "**: " + tag.parsed().description;
        }).join("\n").trim()) || undefined;
        var description = ((_c = method.jsDoc) === null || _c === void 0 ? void 0 : _c.description) || undefined;
        return [
            method.name != null ? markdownHighlight(method.name) : "",
            showVisibility ? method.visibility || "public" : "",
            markdownHighlight(getTypeHintFromMethod(method, checker)),
            "" + (description || "") + (description != null && paramDescription != null ? "\n\n" : "") + (paramDescription || "")
        ];
    })));
    return markdownHeader("Methods", 2, config) + "\n" + markdownTable(rows);
}
/**
 * Returns a markdown table with events
 * @param events
 * @param config
 * @param checker
 */
function eventSection(events, checker, config) {
    var showVisibility = shouldShowVisibility(events, config);
    var rows = [["Event", "Visibility", "Detail", "Description"]];
    rows.push.apply(rows, __spread(events.map(function (event) {
        var _a, _b, _c, _d;
        return [
            (event.name && markdownHighlight(event.name)) || "",
            showVisibility ? event.visibility || "public" : "",
            markdownHighlight(getTypeHintFromType((_a = event.typeHint, (_a !== null && _a !== void 0 ? _a : (_c = (_b = event).type) === null || _c === void 0 ? void 0 : _c.call(_b))), checker)),
            ((_d = event.jsDoc) === null || _d === void 0 ? void 0 : _d.description) || ""
        ];
    })));
    return markdownHeader("Events", 2, config) + "\n" + markdownTable(rows);
}
/**
 * Returns a markdown table with slots
 * @param slots
 * @param config
 */
function slotSection(slots, config) {
    var rows = [["Name", "Permitted Tag Names", "Description"]];
    rows.push.apply(rows, __spread(slots.map(function (slot) {
        var _a;
        return [
            (slot.name && markdownHighlight(slot.name)) || "",
            (slot.permittedTagNames && slot.permittedTagNames.map(function (tagName) { return markdownHighlight(tagName); }).join(" | ")) || "",
            ((_a = slot.jsDoc) === null || _a === void 0 ? void 0 : _a.description) || ""
        ];
    })));
    return markdownHeader("Slots", 2, config) + "\n" + markdownTable(rows);
}
/**
 * Returns a markdown table with attributes.
 * @param members
 * @param checker
 * @param config
 */
function memberAttributeSection(members, checker, config) {
    var e_2, _a;
    var _b, _c, _d, _e;
    var showVisibility = shouldShowVisibility(members, config);
    var rows = [["Attribute", "Visibility", "Type", "Default", "Description"]];
    try {
        // Add members as rows one by one
        for (var members_1 = __values(members), members_1_1 = members_1.next(); !members_1_1.done; members_1_1 = members_1.next()) {
            var member = members_1_1.value;
            var attrName = markdownHighlight(member.attrName);
            var type = markdownHighlight(getTypeHintFromType((_b = member.typeHint, (_b !== null && _b !== void 0 ? _b : (_d = (_c = member).type) === null || _d === void 0 ? void 0 : _d.call(_c))), checker));
            var visibility = member.visibility || "public";
            var def = (member.default !== undefined ? JSON.stringify(member.default) : "") || (member.required && "**required**") || "";
            var comment = ((_e = member.jsDoc) === null || _e === void 0 ? void 0 : _e.description) || "";
            rows.push([attrName, showVisibility ? visibility : "", type, def, comment]);
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (members_1_1 && !members_1_1.done && (_a = members_1.return)) _a.call(members_1);
        }
        finally { if (e_2) throw e_2.error; }
    }
    return markdownHeader("Attributes", 2, config) + "\n" + markdownTable(rows);
}
/**
 * Returns a markdown table with properties
 * @param members
 * @param checker
 * @param config
 */
function memberPropertySection(members, checker, config) {
    var e_3, _a;
    var _b, _c, _d, _e;
    var showVisibility = shouldShowVisibility(members, config);
    var rows = [["Property", "Attribute", "Visibility", "Modifiers", "Type", "Default", "Description"]];
    try {
        // Add properties as rows one by one
        for (var members_2 = __values(members), members_2_1 = members_2.next(); !members_2_1.done; members_2_1 = members_2.next()) {
            var member = members_2_1.value;
            var propName = markdownHighlight(member.propName);
            var attrName = (member.attrName && markdownHighlight(member.attrName)) || "";
            var visibility = member.visibility || "public";
            var type = markdownHighlight(getTypeHintFromType((_b = member.typeHint, (_b !== null && _b !== void 0 ? _b : (_d = (_c = member).type) === null || _d === void 0 ? void 0 : _d.call(_c))), checker));
            var mods = member.modifiers != null ? Array.from(member.modifiers).join(", ") : "";
            var def = (member.default !== undefined ? JSON.stringify(member.default) : "") || (member.required && "**required**") || "";
            var comment = ((_e = member.jsDoc) === null || _e === void 0 ? void 0 : _e.description) || "";
            rows.push([propName, attrName, showVisibility ? visibility : "", mods, type, def, comment]);
        }
    }
    catch (e_3_1) { e_3 = { error: e_3_1 }; }
    finally {
        try {
            if (members_2_1 && !members_2_1.done && (_a = members_2.return)) _a.call(members_2);
        }
        finally { if (e_3) throw e_3.error; }
    }
    return markdownHeader("Properties", 2, config) + "\n" + markdownTable(rows);
}
function shouldShowVisibility(items, config) {
    return (config.visibility != null && config.visibility !== "public" && items.some(function (method) { return method.visibility != null && method.visibility !== "public"; }));
}

/**
 * Vscode json output format transformer.
 * @param results
 * @param program
 * @param config
 */
var vscodeTransformer = function (results, program, config) {
    var checker = program.getTypeChecker();
    // Grab all definitions
    var definitions = results.map(function (res) { return res.componentDefinitions; }).reduce(function (acc, cur) { return __spread(acc, cur); }, []);
    // Transform all definitions into "tags"
    var tags = definitions.map(function (d) { return definitionToHtmlDataTag$1(d, checker); });
    var vscodeJson = {
        version: 1,
        tags: tags,
        globalAttributes: [],
        valueSets: []
    };
    return JSON.stringify(vscodeJson, null, 2);
};
function definitionToHtmlDataTag$1(definition, checker) {
    var declaration = definition.declaration();
    // Transform all members into "attributes"
    var customElementAttributes = arrayDefined(declaration.members.map(function (d) { return componentMemberToVscodeAttr(d, checker); }));
    var eventAttributes = arrayDefined(declaration.events.map(function (e) { return componentEventToVscodeAttr(e, checker); }));
    var attributes = __spread(customElementAttributes, eventAttributes);
    return {
        name: definition.tagName,
        description: formatMetadata(declaration.jsDoc, {
            Events: declaration.events.map(function (e) { var _a, _b; return formatEntryRow(e.name, e.jsDoc, (_b = (_a = e).type) === null || _b === void 0 ? void 0 : _b.call(_a), checker); }),
            Slots: declaration.slots.map(function (s) {
                return formatEntryRow(s.name || " ", s.jsDoc, s.permittedTagNames && s.permittedTagNames.map(function (n) { return "\"" + markdownHighlight(n) + "\""; }).join(" | "), checker);
            }),
            Attributes: declaration.members
                .map(function (m) { var _a, _b; return ("attrName" in m && m.attrName != null ? formatEntryRow(m.attrName, m.jsDoc, m.typeHint || ((_b = (_a = m).type) === null || _b === void 0 ? void 0 : _b.call(_a)), checker) : undefined); })
                .filter(function (m) { return m != null; }),
            Properties: declaration.members
                .map(function (m) { var _a, _b; return ("propName" in m && m.propName != null ? formatEntryRow(m.propName, m.jsDoc, m.typeHint || ((_b = (_a = m).type) === null || _b === void 0 ? void 0 : _b.call(_a)), checker) : undefined); })
                .filter(function (m) { return m != null; })
        }),
        attributes: attributes
    };
}
function componentEventToVscodeAttr(event, checker) {
    var _a, _b;
    return {
        name: "on" + event.name,
        description: formatEntryRow(event.name, event.jsDoc, (_b = (_a = event).type) === null || _b === void 0 ? void 0 : _b.call(_a), checker)
    };
}
function componentMemberToVscodeAttr(member, checker) {
    var _a, _b, _c, _d;
    if (member.attrName == null) {
        return undefined;
    }
    return __assign({ name: member.attrName, description: formatMetadata(formatEntryRow(member.attrName, member.jsDoc, member.typeHint || ((_b = (_a = member).type) === null || _b === void 0 ? void 0 : _b.call(_a)), checker), {
            Property: "propName" in member ? member.propName : undefined,
            Default: member.default === undefined ? undefined : String(member.default)
        }) }, ((member.type && typeToVscodeValuePart((_d = (_c = member).type) === null || _d === void 0 ? void 0 : _d.call(_c), checker)) || {}));
}
/**
 * Converts a type to either a value set or string unions.
 * @param type
 * @param checker
 */
function typeToVscodeValuePart(type, checker) {
    var simpleType = isSimpleType$1(type) ? type : toSimpleType(type, checker);
    switch (simpleType.kind) {
        case SimpleTypeKind.BOOLEAN:
            return { valueSet: "v" };
        case SimpleTypeKind.STRING_LITERAL:
            return { values: [{ name: simpleType.value }] };
        case SimpleTypeKind.ENUM:
            return { values: typesToStringUnion(simpleType.types.map(function (_a) {
                    var type = _a.type;
                    return type;
                })) };
        case SimpleTypeKind.UNION:
            return { values: typesToStringUnion(simpleType.types) };
    }
    return undefined;
}
/**
 * Returns a list of strings that represents the types.
 * Only looks at literal types and strips the rest.
 * @param types
 */
function typesToStringUnion(types) {
    return arrayDefined(types.map(function (t) {
        switch (t.kind) {
            case SimpleTypeKind.STRING_LITERAL:
            case SimpleTypeKind.NUMBER_LITERAL:
                return { name: t.value.toString() };
            default:
                return undefined;
        }
    }));
}
/**
 * Formats description and metadata so that it can be used in documentation.
 * @param doc
 * @param metadata
 */
function formatMetadata(doc, metadata) {
    var _a;
    var metaText = arrayDefined(Object.entries(metadata).map(function (_a) {
        var _b = __read(_a, 2), key = _b[0], value = _b[1];
        if (value == null) {
            return undefined;
        }
        else if (Array.isArray(value)) {
            var filtered = arrayDefined(value);
            if (filtered.length === 0)
                return undefined;
            return key + ":\n\n" + filtered.map(function (v) { return "  * " + v; }).join("\n\n");
        }
        else {
            return key + ": " + value;
        }
    })).join("\n\n");
    var comment = typeof doc === "string" ? doc : ((_a = doc) === null || _a === void 0 ? void 0 : _a.description) || "";
    return "" + (comment || "") + (metadata ? "" + (comment ? "\n\n" : "") + metaText : "") || undefined;
}
/**
 * Formats name, doc and type so that it can be presented in documentation
 * @param name
 * @param doc
 * @param type
 * @param checker
 */
function formatEntryRow(name, doc, type, checker) {
    var _a;
    var comment = typeof doc === "string" ? doc : ((_a = doc) === null || _a === void 0 ? void 0 : _a.description) || "";
    var typeText = typeof type === "string" ? type : type == null ? "" : formatType(type, checker);
    return "" + markdownHighlight(name) + (typeText == null ? "" : " {" + typeText + "}") + (comment == null ? "" : " - ") + (comment || "");
}
/**
 * Formats a type to present in documentation
 * @param type
 * @param checker
 */
function formatType(type, checker) {
    return !isAssignableToSimpleTypeKind(type, SimpleTypeKind.ANY, checker) ? markdownHighlight(toTypeString(type, checker)) : undefined;
}

var transformerFunctionMap = {
    debug: debugJsonTransformer,
    json: jsonTransformer,
    markdown: markdownTransformer,
    md: markdownTransformer,
    vscode: vscodeTransformer
};
/**
 * Transforms the analyzer results into a string representation based on the transformer kind
 * @param kind
 * @param results
 * @param program
 * @param config
 */
function transformAnalyzerResult(kind, results, program, config) {
    if (config === void 0) { config = {}; }
    var func = transformerFunctionMap[kind];
    if (func == null) {
        throw new Error("Couldn't find transformer function for transformer kind: " + kind);
    }
    return func(Array.isArray(results) ? results : [results], program, __assign({ visibility: "public" }, config));
}

export { ALL_COMPONENT_FEATURES as A, CustomElementFlavor as C, DEFAULT_FEATURE_COLLECTION_CACHE as D, VERSION as V, __assign as _, arrayDefined as a, analyzeSourceFile as b, analyzeComponentDeclaration as c, __awaiter as d, __generator as e, __values as f, generateInheritanceTreeText as g, arrayFlat as h, __read as i, makeContextFromConfig as m, stripTypescriptValues as s, transformAnalyzerResult as t };
